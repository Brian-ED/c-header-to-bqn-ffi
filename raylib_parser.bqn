# Command line variables
inFileName â† "./examples/raylib/raylib.h"
outFileName â† "./examples/raylib/raylib.json"
apiDefine â† "RLAPI"       # Functions define (i.e. RLAPI for raylib.h)

jsonâ†â€¢Import"json.bqn"

"
    This parser scans file.h to get API information about defines, structs, aliases, enums, callbacks and functions.
    All data is divided into pieces, usually as strings.

    CONSTRAINTS:

     - Functions are expected as a single line with the following structure:

       <retType> <name>(<paramType[0]> <paramName[0]>, <paramType[1]> <paramName[1]>);  <desc>

       Be careful with functions broken into several lines, it breaks the process!

     - Structures are expected as several lines with the following form:

       <desc>
       typedef struct <name> {
           <fieldType[0]> <fieldName[0]>;  <fieldDesc[0]>
           <fieldType[1]> <fieldName[1]>;  <fieldDesc[1]>
           <fieldType[2]> <fieldName[2]>;  <fieldDesc[2]>
       } <name>;

     - Enums are expected as several lines with the following form:

       <desc>
       typedef enum {
           <valueName[0]> = <valueInteger[0]>, <valueDesc[0]>
           <valueName[1]>,
           <valueName[2]>, <valueDesc[2]>
           <valueName[3]>  <valueDesc[3]>
       } <name>;

       NOTE: Multiple options are supported for enums:
          - If value is not provided, (<valueInteger[i -1]> + 1) is assigned
          - Value description can be provided or not
"

For â† {Iâ€¿Câ€¿Pâ€¿A: I@ â‹„ C â€¢_while_ Pâˆ˜A@}

#----------------------------------------------------------------------------------
# Types and Structures Definition
#----------------------------------------------------------------------------------

# Type of parsed define
âŸ¨
    unknown
    macro
    guard
    int
    int_math
    long
    long_math
    float
    float_math
    double
    double_math
    char
    string
    coloR
âŸ© â† â†•14

#----------------------------------------------------------------------------------
# Module Functions Definition
#----------------------------------------------------------------------------------

# Get data type and name from a string containing both
# NOTE: Useful to parse function parameters and struct fields
# int *hello

GetDataTypeAndName â† âŒˆÂ´âˆ˜âŠâŸœ"* "âŠ¸(â†‘â‹ˆâ†“) #â€¿typeâ€¿name: # const char *typeName, int typeNameLen, char *type, char *name)

# Get comment from a line, do nothing if no comment in line
GetDescription â† âˆ¨`âˆ˜âˆ§âŸœÂ«âˆ˜=âŸœ'/'âŠ¸/ # str â†’ description (str)

# Find first text occurrence within a string
TextFindIndex â† âŠ‘Â¯1âˆ¾Ëœ/âˆ˜â·

# Get string of define type
StrDefineType â† âŠ‘âŸœâŸ¨
    "UNKNOWN"
    "GUARD"
    "MACRO"
    "INT"
    "INT_MATH"
    "LONG"
    "LONG_MATH"
    "FLOAT"
    "FLOAT_MATH"
    "DOUBLE"
    "DOUBLE_MATH"
    "CHAR"
    "STRING"
    "COLOR"
âŸ©

# Preprocess buffer to get separate lines
lines â† ' 'âŸ((9+@)âŠ¸â‰¡)Â¨Â¨ â€¢FLines inFileName

defMacro â† "#define"
CheckHex â† Â¬âˆ¨Â´âˆ˜=âŸœ"0123456789abcdefABCDEFxL.+-"

definesNonStripped â† {ğ•ŠlinePtr:
    type â† 0
    description â† ""
    ishex â† 0
    operand â† ""

    LS â† âˆ¨`âˆ˜=âŸœ' ' # leading spacing
    nameAndArgs â† LSâŠ¸/{ğ”½defMacroâˆ¾â¼ğ”½}linePtr # Skip spaces, then defMacro, then spaces again

    # Extract name
    defineNameStart â† linePtr-â—‹â‰ nameAndArgs
    
    openBraces â† +`-Ë"()"=âŒœnameAndArgs
    
    nameLen â† defineNameEnd â† (âŠâŸœ' 'â‰¤Â·âŠ‘âŠâŸœ'(')â—¶âŸ¨
        1+âŠâŸœ')'
        âŠâŸœ' '
    âŸ© nameAndArgs

    nameâ€¿args â† nameLen(â†‘â‹ˆLSâŠ¸/âˆ˜â†“)nameAndArgs

    # Determine type
    {ğ•Š:typeâ†©macro}âŸâŠ¢')'=Â¯1âŠ‘name
    {ğ•Š:typeâ†©guard}âŸâŠ¢(0=â‰ args)âˆ¨'/'=âŠ‘args

    {'"'=âŠ‘args? typeâ†©string
    ;args=â—‹âŠ‘"'"? typeâ†©char
    ;"CLITERAL(Color)"â‰¡15â†‘args? typeâ†©color
    ;âŠ‘argsâŠ‘âŠ¸âˆŠ'0'+â†•10? # Parsing numbers
        mâ†âˆ§`âˆ˜â‰ âŸœ' 'âŠ¸/args
        m2â†âˆ¨`âˆ˜=âŸœ' 'âŠ¸/args
        isFloat  â† âŠ‘mâˆŠ'.'

        {âŠ‘mâˆŠ'x'?
            {ğ•Š:ishexâ†©CheckHex m}âŸâŠ¢isFloat

            # Found a valid number -> update type
            typeâŒˆâ†©[
                intâ€¿long
                doubleâ€¿float
            ]âŠ‘ËœisFloatâˆ¾(isFloatâŠ‘"Lf")=Â¯1âŠ‘m2
        }
    ;@
    }

    # Extracting value
    fullValue â† âˆ¨`âŒ¾âŒ½âˆ˜â‰ âŸœ' 'âŠ¸/args/ËœÂ¬âˆ¨`0âˆ¾Ëœ"//"â·args
    value â† fullValueâ†“Ëœ-âŠ‘typeâˆŠlongâ€¿float # Remove number postfix

    # Extracting description
    desc â† GetDescription args

    # Parse defines of type UNKNOWN to find calculated numbers
    isMath â† 1
    {ğ•¤

        For (câ†0)â€¿{ğ•Š:c<â‰ value}â€¿{ğ•Š:c+â†©1}â€¿{ğ•¤
            # Skip operators and whitespace
            (âˆ¨Â´(câŠ‘value)="0123456789")âˆ§Â¬âˆ¨Â´(câŠ‘value)="()+-*/ "?
                # Read number operand                
                m â† âˆ§`Â¬"()*/ "âˆŠËœcâ†“value
                v â† m/câ†“value
                h â† âˆ§`Â¬CheckHexÂ¨v
                isNumberâ†âˆ¨Â´CheckHexÂ¨v
                isFloatâ†âˆ¨Â´'.'=h/v
                c+â†©isNumber++Â´h
                
                isMath âˆ§â†© isNumber
                
                {ğ•¤
                    # Found a valid number -> update largestType
                    typeâŒˆâ†©[
                        INT_MATHâ€¿LONG_MATH
                        DOUBLE_MATHâ€¿FLOAT_MATH
                    ]âŠ‘ËœisFloatâ‹ˆ(isFloatâŠ‘"Lf")=valueâŠ‘Ëœc-1
                }âŸâŠ¢isNumber
        ;
                # Read string operand
                operandStart â† c
                c+â†©+Â´Â¬âˆ¨`" ()+-*/"âˆŠËœcâ†“value
                operandEnd â† c

                # Search previous defines for operand
                operand â†© operandStartâ†“operandEndâ†‘value
        }

    }âŸâŠ¢type=unknown

    nameâ€¿typeâ€¿valueâ€¿descriptionâ€¿ishexâ€¿operandâ€¿isMath
}Â¨â†“âŸœlinesÂ¨/defMacroâŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨âˆ¨`âˆ˜=âŸœ' 'âŠ¸/Â¨lines

# Skip duplicates
definesWithRefs â† (âˆŠâŠ‘Â¨)âŠ¸/definesNonStripped

# solve refrences to previously defined defines
definesâ†{lastDefinesğ•Šnameâ€¿typeâ€¿valueâ€¿descriptionâ€¿ishexâ€¿operandâ€¿isMath:
    foundOperand â† âˆ¨Â´{ğ•Šlastnameâ€¿lasttypeâ€¿lastvalueâ€¿lastdescriptionâ€¿lastishexâ€¿lastoperand:
        ((â‰¥âŸœintâˆ§â‰¤âŸœdouble_math) lastType)âˆ§lastname â‰¡ operand?
            type âŒˆâ†© lastType
            1
    ;0
    }Â¨lastDefines

    isMath>â†©foundOperand

    {ğ•¤
        # Define is a calculated number -> update type
        type {
            ğ•© = int    ? int_math
            ğ•© = long   ? long_math
            ğ•© = float  ? float_math
            ğ•© = double ? double_math
        }â†©
    }âŸâŠ¢isMath


    nameâ€¿typeâ€¿valueâ€¿descriptionâ€¿ishexâ€¿operand
}{(Â¯1â†“ğ•©)ğ”½Â¨Â¯1âŠ‘ğ•©}Â¨1â†“â†‘definesWithRefs


# Structs info data
structs â† {ğ•¤
    linesPtr â† ğ•©â†“lines

    # Parse struct description
    desc â† GetDescription (ğ•©-1)âŠ‘linesPtr

    # Get struct name: typedef struct name {
    nameâ†' 'âŠ¸â‰ âŠ¸/âˆ§`âˆ˜â‰ âŸœ'{'âŠ¸/"typedef struct "âˆ¾â¼âŠ‘linesPtr

    # Get struct fields and count them -> fields finish with ;
    fields â† âŸ¨âŸ©âˆ¾Â´{
        fieldTypeâ€¿fieldNamesUnparsed â† GetDataTypeAndName âŠâŸœ';'âŠ¸â†‘ğ•©
        fieldNamesâ†','((âŠ¢-Ëœ+`Ã—Â¬)âˆ˜=âŠ”âŠ¢)fieldNamesUnparsed
        fieldDesc â† GetDescription ğ•©

        # Move type len info from name to type
        fieldTypes â† {fieldTypeâˆ¾1â†“Â¯1â†“âˆ¨`âˆ˜=âŸœ'['âŠ¸/ğ•©}Â¨fieldnames
        fieldnames âˆ§`âˆ˜â‰ âŸœ'['âŠ¸/Â¨â†©

        (<fieldDesc)âˆ¾Ë˜fieldTypesâ‰Ë˜fieldNames
    }âŸ((' 'â‰ âŠ‘)âˆ§Â·âˆ§Â´"struct"â€¿"/"â‰¢Â¨6â€¿1â†‘Â¨<)Â¨(âˆ§`'}'=Â·âˆ¾1âŠ¸â†‘Â¨)âŠ¸/1â†“linesPtr

    nameâ€¿descâ€¿fields

    # Read struct lines
    # Find structs
    # starting with "typedef struct ... {" or "typedef struct ... ; \n struct ... {"
    # ending with "} ... ;"
    # i.e. excluding "typedef struct rAudioBuffer rAudioBuffer;" -> Typedef and forward declaration only
}Â¨/{
    [m1,m2]â†"typedef struct"â€¿"struct"(âŠ£â‰¡â‰ âŠ¸â†‘)âŒœğ•©
    m1âˆ§m2Â«âŠ¸âˆ¨<Â´âˆ˜âŠâŸœ"{;"Â¨ğ•©
} lines


# Alias info data
aliases â† {ğ•¤
    linePtr â†ğ•©âŠ‘lines
    desc â† (linesâŠ‘Ëœğ•©-1)âŠ£âŸ(""âŠ¸â‰¡)â—‹GetDescription linePtr
    typeâ€¿name â† ' '((Â¬-ËœâŠ¢Ã—Â·+`Â»âŠ¸>)âˆ˜â‰ âŠ”âŠ¢)"typedef "âˆ¾â¼âŠâŸœ'/'âŠ¸â†‘linePtr  
    typeâ€¿nameâ€¿desc
}Â¨/(âˆ¨Â´âˆ˜=âŸœ';'âˆ§"typedef"âŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)âˆ§2=(+Â´' 'âŠ¸=>âˆ¨`âˆ˜=âŸœ';'))Â¨lines # Find aliases (lines with "typedef ... ...;")

enums â† {
    # Parse enum description
    # NOTE: This is not necessarily from the line immediately before,
    # some of the enums have extra lines between the "description"
    # and the typedef enum
    desc â† GetDescription âŠ‘(âˆ§`("// "â‰¡3âŠ¸â†‘)Â¨)âŠ¸/âŒ¾âŒ½ğ•©â†‘lines

    # Parse enum value line, possible options:
    #ENUM_VALUE_NAME,
    #ENUM_VALUE_NAME
    #ENUM_VALUE_NAME     = 99
    #ENUM_VALUE_NAME     = 99,
    #ENUM_VALUE_NAME     = 0x00000040,   # Value description
    values â† {ğ•¤
        valueInteger â† âŸ¨âŸ©

        # We start reading the value name
        valueNameâ†(âˆ§`âˆ§Ë", ="â‰ âŒœâŠ¢)âŠ¸/ğ•©

        # After the name we can have:
        #  '='  -> value is provided
        #  ','  -> value is equal to previous + 1, there could be a description if not '\0'
        #  ' '  -> value is equal to previous + 1, there could be a description if not '\0'
        #  '\0' -> value is equal to previous + 1

        # Let's start checking if the line is not finished
        # Two options:
        #  '='  -> value is provided
        #  ' '  -> value is equal to previous + 1, there could be a description if not '\0'
        
        valuesUnparsedâ†' 'âŠ¸â‰ âŠ¸/valueNameâˆ¾â¼âŠâŸœ'/'âŠ¸â†‘ğ•©

        value â† ('='=âŠ‘)â—¶âŸ¨@â‹„â€¢ParseFloat'='âŠ¸âˆ¾â¼âŸ©valuesUnparsed

        # Parse value description
        valueDesc â† GetDescription ğ•©

        valueNameâ€¿valueâ€¿valueDesc
    }Â¨(â‰¥âŸœ'A'âˆ§'Z'âŠ¸â‰¥)âˆ˜âŠ‘Â¨âŠ¸/ âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/Â¨(linesâ†“Ëœ1+ğ•©)/Ëœmâ†âˆ§`'}'â‰ âŠ‘Â¨linesâ†“Ëœ1+ğ•©
    
    values {ğ•©=@?ğ•¨+1;ğ•©}`âŒ¾(1âŠ¸âŠ‘)Â¨â†©

    # Get enum name from typedef
    nameâ†"} "âˆ¾â¼âŠâŸœ';'âŠ¸â†‘linesâŠ‘Ëœ1+ğ•©

    nameâ€¿descâ€¿values

    # Read enum lines
    # ignore inline enums
}Â¨ /("typedef enum {"âŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)âˆ§âˆ¨Â´âˆ˜=âŸœ';')Â¨lines

callbacks â† {
    RLS â† âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/
    
    # Return type
    afterDef â† RLS "typedef "âˆ¾â¼ğ•©
    retType â† RLSâŒ¾âŒ½ âŠâŸœ'('âŠ¸â†‘afterDef
    afterStar â† RLS "(*"âˆ¾â¼ RLS retTypeâˆ¾â¼RLS afterDef
    name â† RLSâŒ¾âŒ½ âŠâŸœ')'âŠ¸â†‘ afterStar
    afterName â† RLS")("âˆ¾â¼RLS nameâˆ¾â¼afterStar

    # âŸ¨paramTypeâ€¿paramName, ...âŸ©
    [paramTypes,paramNames] â† â‰>GetDataTypeAndNameÂ¨ ','((âŠ¢-Ëœ+`Ã—Â¬)âˆ˜=âŠ”âŠ¢) âŠâŸœ')'âŠ¸â†‘afterName

    # Move array sizes from name to type
    paramTypesâˆ¾Â¨â†©âŠâŸœ'['âŠ¸â†“Â¨paramNames
    paramNames âŠâŸœ'['âŠ¸â†“â†©

    # Description
    desc â† GetDescription ğ•©

    paramCountâ†â‰ paramNames
    nameâ€¿descâ€¿retTypeâ€¿paramTypesâ€¿paramNames
}Â¨{
    # Read callback lines
    # Find callbacks (lines with "typedef ... (* ... )( ... );")
    m1â†"typedef"âŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨ğ•©
    m1âˆ§{((âˆ¨Â´");"âŠ¸â‰¡Ë˜)<(âˆ¨Â´")("âŠ¸â‰¡Ë˜)âˆ§(âˆ¨Â´"(*"âŠ¸â‰¡Ë˜))2â†•" "âŸ(""âŠ¸â‰¡)ğ•©}Â¨ğ•©
}âŠ¸/lines

funcsâ†{
    funcSignature â† ğ•©âˆ¾â¼ËœapiDefineâˆ¾' '

    retTypeâ€¿name â† GetDataTypeAndName âŠâŸœ'('âŠ¸â†‘funcSignature

    [paramTypesâ‹„paramNames]â†âŸ¨âŸ©âŠ¸â‰¢â—¶âŸ¨â†•2â€¿0â‹„â‰>âŸ©("void"â‰¢Â¯4âŠ¸â†‘)â—¶âŸ¨
        âŸ¨âŸ© â‹„ {GetDataTypeAndNameÂ¨(âˆ¨`âˆ§âˆ¨âŸœÂ«)âˆ˜â‰ âŸœ' 'âŠ¸/Â¨','((âŠ¢-Ëœ+`Ã—Â¬)âˆ˜=âŠ”âŠ¢)ğ•©}
    âŸ© âŠâŸœ')'âŠ¸â†‘(1+âŠâŸœ'(')âŠ¸â†“funcSignature

    # Move array sizes from name to type
    paramTypesâˆ¾Â¨â†©âŠâŸœ'['âŠ¸â†“Â¨paramNames
    paramNames âŠâŸœ'['âŠ¸â†‘Â¨â†©

    desc â† GetDescription ğ•©

    nameâ€¿descâ€¿retTypeâ€¿paramNamesâ€¿paramTypes

    # Read function lines
    # Read function line (starting with `define`)
}Â¨apiDefineâŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨âŠ¸/lines

â€¢Out"Input file:  "âˆ¾inFileName
â€¢Out"Output file: "âˆ¾outFileName

EscapeBackslashesâ†âˆ¾'\'âŠ¸=â—¶â‹ˆâ€¿"//"Â¨
# Export parsed data in json
parsedData â† âˆ¾âŸ¨
    â‹ˆ"{"

    # Print defines info
    â‹ˆ"  ""defines"": ["
    Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âˆ¾{ğ•Šnameâ€¿typeâ€¿valueâ€¿descriptionâ€¿ishexâ€¿operand:âˆ¾âŸ¨
        â‹ˆ"    {"
        â‹ˆ"      ""name"": """âˆ¾nameâˆ¾""","
        â‹ˆ"      ""type"": """âˆ¾(StrDefineType type)âˆ¾""","
        {isHex? # INT or LONG
            "      ""value"": "âˆ¾(16âŠ¸Ã—âŠ¸+ËœÂ´âŒ½valueâŠËœâˆ¾"0A"+âŸœâ†•Â¨10â€¿6)âˆ¾","
        ;âˆ¨Â´type = INTâ€¿LONGâ€¿FLOATâ€¿DOUBLEâ€¿STRING?
            "      ""value"": "âˆ¾valueâˆ¾','
        ;
            "      ""value"": """âˆ¾valueâˆ¾""","
        }
        â‹ˆ"      ""description"": """âˆ¾descriptionâˆ¾""""
        â‹ˆ"    },"
    âŸ©}Â¨defines
    â‹ˆ"  ],"
    # Print structs info
    â‹ˆ"  ""structs"": ["
    Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âˆ¾{ğ•Šnameâ€¿descâ€¿fields:âŸ¨
        â‹ˆ"    {"
        â‹ˆ"      ""name"": """âˆ¾nameâˆ¾""","
        â‹ˆ"      ""description"": """âˆ¾(EscapeBackslashes desc)âˆ¾""","
        â‹ˆ"      ""fields"": ["
        âˆ¾Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢){ğ•ŠfieldDescâ€¿fieldTypeâ€¿fieldName:âŸ¨
            "        {"
            "          ""type"": """âˆ¾fieldTypeâˆ¾""","
            "          ""name"": """âˆ¾fieldNameâˆ¾""","
            "          ""description"": """âˆ¾(EscapeBackslashes fieldDesc)âˆ¾""""
            "        },"
        âŸ©}Â¨<Ë˜fields

        â‹ˆ"      ]"
        â‹ˆ"    },"
    âŸ©}Â¨structs
    â‹ˆ"  ],"

    # Print aliases info
    â‹ˆ"  ""aliases"": ["
    Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âˆ¾{ğ•Štypeâ€¿nameâ€¿desc:âŸ¨
        "    {"
        "      ""type"": """âˆ¾typeâˆ¾""","
        "      ""name"": """âˆ¾nameâˆ¾""","
        "      ""description"": """âˆ¾descâˆ¾'"'
        "    },"
    âŸ©}Â¨aliases
    â‹ˆ"  ],"

    # Print enums info
    â‹ˆ"  ""enums"": ["
    Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âˆ¾{ğ•Šnameâ€¿descâ€¿values:
        âˆ¾âŸ¨
            â‹ˆ"    {"
            â‹ˆ"      ""name"": """âˆ¾nameâˆ¾""","
            â‹ˆ"      ""description"": """âˆ¾(EscapeBackslashes desc)âˆ¾""","
            â‹ˆ"      ""values"": ["
            Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âˆ¾{ğ•ŠvalueNameâ€¿valueâ€¿valueDesc:
                âŸ¨
                    "        {"
                    "          ""name"": """âˆ¾valueNameâˆ¾""","
                    "          ""value"": "âˆ¾valueâˆ¾","
                    "          ""description"": """âˆ¾(EscapeBackslashes valueDesc)âˆ¾'"'
                    "        },"
                âŸ©
            }Â¨values
            â‹ˆ"      ]"
            â‹ˆ"    },"
        âŸ©
    }Â¨enums
    â‹ˆ"  ],"

    # Print callbacks info
    â‹ˆ"  ""callbacks"": ["
    Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âˆ¾{ğ•Šnameâ€¿descâ€¿retTypeâ€¿paramTypesâ€¿paramNames:âˆ¾âŸ¨
        â‹ˆ"    {"
        â‹ˆ"      ""name"": """âˆ¾nameâˆ¾""","
        â‹ˆ"      ""description"": """âˆ¾(EscapeBackslashes desc)âˆ¾""",",
        â‹ˆ"      ""returnType"": """âˆ¾retTypeâˆ¾""","
        â‹ˆ"      ""params"": ["
        Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âˆ¾paramTypes{ğ•Šp:
            "        {"
            "          ""type"": """âˆ¾ğ•¨âˆ¾"""," 
            "          ""name"": """âˆ¾ğ•©âˆ¾""""  
            "        },"
        }Â¨paramNames
        â‹ˆ"      ]"
        â‹ˆ"    },"
    âŸ©}Â¨callbacks
    â‹ˆ"  ],"

    # Print functions info
    â‹ˆ"  ""functions"": ["
    Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âˆ¾{ğ•Šnameâ€¿descâ€¿retTypeâ€¿paramNamesâ€¿paramTypes: 
        âˆ¾âŸ¨
            â‹ˆ"    {"
            â‹ˆ"      ""name"": """âˆ¾nameâˆ¾""","
            â‹ˆ"      ""description"": """âˆ¾(EscapeBackslashes desc)âˆ¾""","
            â‹ˆ"      ""returnType"": """âˆ¾retTypeâˆ¾""","
            âˆ¾âŸ¨
                â‹ˆ"      ""params"": ["
                âˆ¾paramTypes{
                    âŸ¨
                        "        {"
                        "          ""type"": """âˆ¾ğ•¨âˆ¾""","
                        "          ""name"": """âˆ¾ğ•©âˆ¾'"'
                        "        }"
                        ","
                    âŸ©
                }Â¨paramNames
                â‹ˆ"      ]"
            âŸ©
            â‹ˆ"    },"
        âŸ©
    }Â¨funcs

    â‹ˆ"  ]"
    â‹ˆ"}"
âŸ©

outFileName â€¢FLines â€¢SHowÂ¨ parsedData