# Command line variables
inFileName â† "./examples/raylib/raylib.h"
outFileName â† "./examples/raylib/raylib.json"
apiDefine â† "RLAPI"       # Functions define (i.e. RLAPI for raylib.h)

jsonâ†â€¢Import"json.bqn"

"
    This parser scans file.h to get API information about defines, structs, aliases, enums, callbacks and functions.
    All data is divided into pieces, usually as strings.

    CONSTRAINTS:

     - Functions are expected as a single line with the following structure:

       <retType> <name>(<paramType[0]> <paramName[0]>, <paramType[1]> <paramName[1]>);  <desc>

       Be careful with functions broken into several lines, it breaks the process!

     - Structures are expected as several lines with the following form:

       <desc>
       typedef struct <name> {
           <fieldType[0]> <fieldName[0]>;  <fieldDesc[0]>
           <fieldType[1]> <fieldName[1]>;  <fieldDesc[1]>
           <fieldType[2]> <fieldName[2]>;  <fieldDesc[2]>
       } <name>;

     - Enums are expected as several lines with the following form:

       <desc>
       typedef enum {
           <valueName[0]> = <valueInteger[0]>, <valueDesc[0]>
           <valueName[1]>,
           <valueName[2]>, <valueDesc[2]>
           <valueName[3]>  <valueDesc[3]>
       } <name>;

       NOTE: Multiple options are supported for enums:
          - If value is not provided, (<valueInteger[i -1]> + 1) is assigned
          - Value description can be provided or not
"


#----------------------------------------------------------------------------------
# Types and Structures Definition
#----------------------------------------------------------------------------------

# Type of parsed define
âŸ¨
    unknown
    macro
    guard
    int
    int_math
    long
    long_math
    float
    float_math
    double
    double_math
    char
    string
    coloR
âŸ© â† â†•14

#----------------------------------------------------------------------------------
# Module Functions Definition
#----------------------------------------------------------------------------------

# Get data type and name from a string containing both
# NOTE: Useful to parse function parameters and struct fields
# int *hello

GetDataTypeAndName â† (âˆ¨`âŒ¾âŒ½âˆŠâŸœ"* ">âˆ¨`âˆ˜=âŸœ',')âŠ¸(/â‹ˆÂ¬âŠ¸/) #â€¿typeâ€¿name: # const char *typeName, int typeNameLen, char *type, char *name)

# Get comment from a line, do nothing if no comment in line
GetDescription â† âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/2â†“âˆ¨`âˆ˜âˆ§âŸœÂ«âˆ˜=âŸœ'/'âŠ¸/ # str â†’ description (str)

# Find first text occurrence within a string
TextFindIndex â† âŠ‘Â¯1âˆ¾Ëœ/âˆ˜â·

# Get string of define type
StrDefineType â† âŠ‘âŸœâŸ¨
    "UNKNOWN"
    "MACRO"
    "GUARD"
    "INT"
    "INT_MATH"
    "LONG"
    "LONG_MATH"
    "FLOAT"
    "FLOAT_MATH"
    "DOUBLE"
    "DOUBLE_MATH"
    "CHAR"
    "STRING"
    "COLOR"
âŸ©

# Preprocess buffer to get separate lines
lines â† ' 'âŸ((9+@)âŠ¸â‰¡)Â¨Â¨ â€¢FLines inFileName

defMacro â† "#define"
CheckHex â† Â¬âˆ¨Â´âˆ˜=âŸœ"0123456789abcdefABCDEFxL.+-"

defines â† (âˆŠâŠ‘Â¨)âŠ¸/ Â¯1âŠ‘Â¨{lastDefinesğ•ŠlinePtr:
    type â† 0
    ishex â† 0
    operand â† âŸ¨âŸ©

    LS â† âˆ¨`âˆ˜â‰ âŸœ' ' # leading spacing
    nameAndArgs â† LSâŠ¸/ defMacroâˆ¾â¼LSâŠ¸/âŠ‘linePtr # Skip defMacro, then spaces again

    # Extract name    
    nameLen â† â‰¤Â´âˆ˜âŠâŸœ" ("â—¶âŸ¨
        1+âŠâŸœ')'
        âŠâŸœ' '
    âŸ© nameAndArgs

    nameâ€¿args â† nameLen(â†‘â‹ˆLSâŠ¸/âˆ˜â†“)nameAndArgs

    # Determine type
    {ğ•Š:typeâ†©macro}âŸâŠ¢')'=Â¯1âŠ‘name
    {ğ•Š:typeâ†©guard}âŸâŠ¢(0=â‰ args)âˆ¨"/"â‰¡1â†‘args

    {
        """"â‰¡1â†‘args?
            typeâ†©string
    ;
        "'"â‰¡1â†‘args?
            typeâ†©char
    ;
        "CLITERAL(Color)"â‰¡15â†‘args?
            typeâ†©color
    ;
        âŠ‘"0123456789"âˆŠËœ1â†‘args?
            chars â† âˆ§`âˆ˜â‰ âŸœ' 'âŠ¸/args
            isFloat â† âˆ¨Â´'.'=chars
            isHexTemp â† âˆ¨Â´'x'=chars

            {ğ•¤
                isFloat?
                    type â†© (ğ•©='f')âŠ‘doubleâ€¿float
            ;
                    type â†© (ğ•©='L')âŠ‘intâ€¿long
                    isHex â†© isHexTemp
            }Â¨(Â¬âˆ˜Â«âˆŠâŸœ"0123456789xL.+-ABCDEFabcdef")âŠ¸/chars
    ;@
    }

    # Extracting value
    fullValue â† âˆ¨`âŒ¾âŒ½âˆ˜â‰ âŸœ' 'âŠ¸/args/ËœÂ¬âˆ¨`(â‰ args)â†‘"//"â·args
    value â† fullValueâ†“Ëœ-âŠ‘typeâˆŠlongâ€¿float # Remove number postfix

    # Extracting description
    description â† GetDescription args

    # Parse defines of type UNKNOWN to find calculated numbers
    isMath â† 1
    {ğ•¤
        conds â† (âˆŠâŸœ"0123456789.">âˆŠâŸœ"()+-*/ ")value
        numbers â† conds (Â¬-ËœâŠ¢Ã—Â·+`Â»âŠ¸>)âŠ¸âŠ” value 
        operands â† (Â¬conds) (Â¬-ËœâŠ¢Ã—Â·+`Â»âŠ¸>)âŠ¸âŠ” value 
        areNumbers â† âˆ¨Â´Â¨âˆŠâŸœ"0123456789xL.+-abcdefABCDEF"Â¨numbers
        isMathâ†©âˆ§Â´areNumbers
        
        # Read number operand
        # Found a valid number -> update largestType
        type âŒˆâ†© âŒˆÂ´{
            isFloatâ†âˆ¨Â´('.'=ğ•©)âˆ§âˆ§`Â¬CheckHexÂ¨ğ•©
            [
                long_mathâ€¿int_math
                float_mathâ€¿double_math
            ]âŠ‘ËœisFloat(âŠ£â‹ˆâŠ‘)"Lf"=âŠ‘ğ•©
        }Â¨areNumbers/numbers
        {
            # Search previous defines for operand
            # Found operand and it's a number -> update type
            foundOperandsâ†(âˆ§`â‰¥âŸœintâˆ§â‰¤âŸœdouble_math)âŠ¸/((ğ•©â‰¡âŠ‘)Â¨/1âŠ¸âŠ‘Â¨)2â†‘Â¨lastDefines

            typeâŒˆâ†©âŒˆÂ´foundOperands
            isMathâˆ§â†©0<â‰ foundOperands
        }Â¨operands
        {ğ•¤
            # Define is a calculated number -> update type
            mathTypes â† int_mathâ€¿long_mathâ€¿float_mathâ€¿double_mathâ€¿type
            typeâ†©mathTypesâŠ‘ËœâŠ‘intâ€¿longâ€¿floatâ€¿doubleâŠtype
        }âŸâŠ¢isMath
    }âŸâŠ¢type=unknown
    lastNamesâ†âŠ‘Â¨lastDefines
    ğ•¨ âˆ¾âŸœ< nameâ€¿typeâ€¿valueâ€¿descriptionâ€¿ishexâ€¿operand
}`Â´(<âŸ¨âŸ©)â‹ˆâ†“âŸœlinesÂ¨/defMacroâŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/Â¨lines

# Structs info data
structs â† {ğ•¤
    linesPtr â† ğ•©â†“lines

    # Parse struct description
    desc â† GetDescription (ğ•©-1)âŠ‘lines

    # Get struct name: typedef struct name {
    nameâ†' 'âŠ¸â‰ âŠ¸/âˆ§`âˆ˜â‰ âŸœ'{'âŠ¸/"typedef struct "âˆ¾â¼âŠ‘linesPtr

    # Get struct fields and count them -> fields finish with ;
    fields â† âˆ¾Â´{
        fieldTypeâ€¿fieldNamesUnparsed â† GetDataTypeAndName âŠâŸœ';'âŠ¸â†‘ğ•©
        fieldType âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/âŒ¾âŒ½â†©
        fieldNames â† ','((âŠ¢-Ëœ+`Ã—Â¬)âˆ˜=âŠ”âŠ¢)fieldNamesUnparsed
        fieldNames âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/Â¨â†©
        fieldDesc  â†  GetDescription ğ•©

        # Move type len info from name to type
        fieldTypes â† {fieldTypeâˆ¾âˆ¨`âˆ˜=âŸœ'['âŠ¸/ğ•©}Â¨fieldnames
        fieldnames âˆ§`âˆ˜â‰ âŸœ'['âŠ¸/Â¨â†©

        (<fieldDesc)âŠ¸âˆ¾Â¨fieldTypesâ‹ˆÂ¨fieldNames
    }Â¨(âˆ§Â´"struct"â€¿"/"â€¿" "â‰¢Â¨6â€¿1â€¿1â†‘Â¨<)Â¨âŠ¸/âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/Â¨(âˆ§`'}'â‰ Â·âˆ¾Â´1âŠ¸â†‘Â¨)âŠ¸/1â†“linesPtr

    nameâ€¿descâ€¿fields

    # Read struct lines
    # Find structs
    # starting with "typedef struct ... {" or "typedef struct ... ; \n struct ... {"
    # ending with "} ... ;"
    # i.e. excluding "typedef struct rAudioBuffer rAudioBuffer;" -> Typedef and forward declaration only
}Â¨/{
    [m1,m2]â†"typedef struct"â€¿"struct"(âŠ£â‰¡â‰ âŠ¸â†‘)âŒœğ•©
    m1âˆ§m2Â«âŠ¸âˆ¨<Â´âˆ˜âŠâŸœ"{;"Â¨ğ•©
} lines


# Alias info data
aliases â† {ğ•¤
    linePtr â†ğ•©âŠ‘lines
    desc â† (linesâŠ‘Ëœğ•©-1)âŠ£âŸ(""âŠ¸â‰¡)â—‹GetDescription linePtr
    typeâ€¿name â† ' '((Â¬-ËœâŠ¢Ã—Â·+`Â»âŠ¸>)âˆ˜â‰ âŠ”âŠ¢)"typedef "âˆ¾â¼âŠâŸœ'/'âŠ¸â†‘linePtr  
    name âˆ¾âŸœ";"â¼â†©
    typeâ€¿nameâ€¿desc
}Â¨/(âˆ¨Â´âˆ˜=âŸœ';'âˆ§"typedef"âŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)âˆ§2=(+Â´' 'âŠ¸=>âˆ¨`âˆ˜=âŸœ';'))Â¨lines # Find aliases (lines with "typedef ... ...;")

enums â† {
    # Parse enum description
    # NOTE: This is not necessarily from the line immediately before,
    # some of the enums have extra lines between the "description"
    # and the typedef enum
    desc â† GetDescription âŠ‘(âˆ§`("// "â‰¡3âŠ¸â†‘)Â¨)âŠ¸/âŒ¾âŒ½ğ•©â†‘lines

    # Parse enum value line, possible options:
    #ENUM_VALUE_NAME,
    #ENUM_VALUE_NAME
    #ENUM_VALUE_NAME     = 99
    #ENUM_VALUE_NAME     = 99,
    #ENUM_VALUE_NAME     = 0x00000040,   # Value description
    values â† {ğ•¤
        valueInteger â† âŸ¨âŸ©

        # We start reading the value name
        valueNameâ†(âˆ§`âˆ§Ë", ="â‰ âŒœâŠ¢)âŠ¸/ğ•©

        # After the name we can have:
        #  '='  -> value is provided
        #  ','  -> value is equal to previous + 1, there could be a description if not '\0'
        #  ' '  -> value is equal to previous + 1, there could be a description if not '\0'
        #  '\0' -> value is equal to previous + 1

        # Let's start checking if the line is not finished
        # Two options:
        #  '='  -> value is provided
        #  ' '  -> value is equal to previous + 1, there could be a description if not '\0'
        
        valuesUnparsedâ†' 'âŠ¸â‰ âŠ¸/valueNameâˆ¾â¼âŠâŸœ'/'âŠ¸â†‘ğ•©

        value â† ('='=âŠ‘)â—¶âŸ¨@â‹„â€¢ParseFloat'='âŠ¸âˆ¾â¼âŸ©valuesUnparsed

        # Parse value description
        valueDesc â† GetDescription ğ•©

        valueNameâ€¿valueâ€¿valueDesc
    }Â¨(â‰¥âŸœ'A'âˆ§'Z'âŠ¸â‰¥)âˆ˜âŠ‘Â¨âŠ¸/ âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/Â¨(linesâ†“Ëœ1+ğ•©)/Ëœmâ†âˆ§`'}'â‰ âŠ‘Â¨linesâ†“Ëœ1+ğ•©
    
    values {ğ•©=@?ğ•¨+1;ğ•©}`âŒ¾(1âŠ¸âŠ‘)Â¨â†©

    # Get enum name from typedef
    nameâ†"} "âˆ¾â¼âŠâŸœ';'âŠ¸â†‘linesâŠ‘Ëœ1+ğ•©

    nameâ€¿descâ€¿values

    # Read enum lines
    # ignore inline enums
}Â¨ /("typedef enum {"âŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)âˆ§âˆ¨Â´âˆ˜=âŸœ';')Â¨lines

callbacks â† {
    RLS â† âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/
    
    # Return type
    afterDef â† RLS "typedef "âˆ¾â¼ğ•©
    retType â† RLSâŒ¾âŒ½ âŠâŸœ'('âŠ¸â†‘afterDef
    afterStar â† RLS "(*"âˆ¾â¼ RLS retTypeâˆ¾â¼RLS afterDef
    name â† RLSâŒ¾âŒ½ âŠâŸœ')'âŠ¸â†‘ afterStar
    afterName â† RLS")("âˆ¾â¼RLS nameâˆ¾â¼afterStar

    # âŸ¨paramTypeâ€¿paramName, ...âŸ©
    [paramTypes,paramNames] â† â‰>GetDataTypeAndNameÂ¨ ','((âŠ¢-Ëœ+`Ã—Â¬)âˆ˜=âŠ”âŠ¢) âŠâŸœ')'âŠ¸â†‘afterName

    # Move array sizes from name to type
    paramTypesâˆ¾Â¨â†©âŠâŸœ'['âŠ¸â†“Â¨paramNames
    paramNames âŠâŸœ'['âŠ¸â†“â†©

    # Description
    desc â† GetDescription ğ•©

    paramCountâ†â‰ paramNames
    nameâ€¿descâ€¿retTypeâ€¿paramTypesâ€¿paramNames
}Â¨{
    # Read callback lines
    # Find callbacks (lines with "typedef ... (* ... )( ... );")
    m1â†"typedef"âŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨ğ•©
    m1âˆ§{((âˆ¨Â´");"âŠ¸â‰¡Ë˜)<(âˆ¨Â´")("âŠ¸â‰¡Ë˜)âˆ§(âˆ¨Â´"(*"âŠ¸â‰¡Ë˜))2â†•" "âŸ(""âŠ¸â‰¡)ğ•©}Â¨ğ•©
}âŠ¸/lines

funcsâ†{
    funcSignature â† ğ•©âˆ¾â¼ËœapiDefineâˆ¾' '

    retTypeâ€¿name â† GetDataTypeAndName âŠâŸœ'('âŠ¸â†‘funcSignature

    [paramTypesâ‹„paramNames]â†âŸ¨âŸ©âŠ¸â‰¢â—¶âŸ¨â†•2â€¿0â‹„â‰>âŸ©("void"â‰¢Â¯4âŠ¸â†‘)â—¶âŸ¨
        âŸ¨âŸ© â‹„ {GetDataTypeAndNameÂ¨(âˆ¨`âˆ§âˆ¨âŸœÂ«)âˆ˜â‰ âŸœ' 'âŠ¸/Â¨','((âŠ¢-Ëœ+`Ã—Â¬)âˆ˜=âŠ”âŠ¢)ğ•©}
    âŸ© âŠâŸœ')'âŠ¸â†‘(1+âŠâŸœ'(')âŠ¸â†“funcSignature

    # Move array sizes from name to type
    paramTypesâˆ¾Â¨â†©âŠâŸœ'['âŠ¸â†“Â¨paramNames
    paramNames âŠâŸœ'['âŠ¸â†‘Â¨â†©

    desc â† GetDescription ğ•©

    nameâ€¿descâ€¿retTypeâ€¿paramNamesâ€¿paramTypes

    # Read function lines
    # Read function line (starting with `define`)
}Â¨apiDefineâŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨âŠ¸/lines

â€¢Out"Input file:  "âˆ¾inFileName
â€¢Out"Output file: "âˆ¾outFileName

EscapeBackslashesâ†âˆ¾'\'âŠ¸=â—¶â‹ˆâ€¿"\\"Â¨
# Export parsed data in json
parsedData â† âˆ¾âŸ¨
    â‹ˆ"{"

    # Print defines info
    â‹ˆ"  ""defines"": ["
    Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âˆ¾{ğ•Šnameâ€¿typeâ€¿valueâ€¿descriptionâ€¿ishexâ€¿operand:âˆ¾âŸ¨
        â‹ˆ"    {"
        â‹ˆ"      ""name"": """âˆ¾nameâˆ¾""","
        â‹ˆ"      ""type"": """âˆ¾(StrDefineType type)âˆ¾""","
        â‹ˆ{isHex? # INT or LONG
            "      ""value"": "âˆ¾(16âŠ¸Ã—âŠ¸+ËœÂ´âŒ½valueâŠËœâˆ¾"0A"+âŸœâ†•Â¨10â€¿6)âˆ¾","
        ;âˆ¨Â´type = INTâ€¿LONGâ€¿FLOATâ€¿DOUBLEâ€¿STRING?
            "      ""value"": "âˆ¾valueâˆ¾','
        ;
            "      ""value"": """âˆ¾valueâˆ¾""","
        }
        â‹ˆ"      ""description"": """âˆ¾descriptionâˆ¾""""
        â‹ˆ"    },"
    âŸ©}Â¨defines
    â‹ˆ"  ],"
    # Print structs info
    â‹ˆ"  ""structs"": ["
    Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âˆ¾{ğ•Šnameâ€¿descâ€¿fields:âˆ¾âŸ¨
        â‹ˆ"    {"
        â‹ˆ"      ""name"": """âˆ¾nameâˆ¾""","
        â‹ˆ"      ""description"": """âˆ¾(EscapeBackslashes desc)âˆ¾""","
        â‹ˆ"      ""fields"": ["
        Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âŸ¨âŸ©âˆ¾Â´{ğ•ŠfieldDescâ€¿fieldTypeâ€¿fieldName:âŸ¨
            "        {"
            "          ""type"": """âˆ¾fieldTypeâˆ¾""","
            "          ""name"": """âˆ¾fieldNameâˆ¾""","
            "          ""description"": """âˆ¾(EscapeBackslashes fieldDesc)âˆ¾""""
            "        },"
        âŸ©}Â¨fields
        â‹ˆ"      ]"
        â‹ˆ"    },"
    âŸ©}Â¨structs
    â‹ˆ"  ],"

    # Print aliases info
    â‹ˆ"  ""aliases"": ["
    Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âˆ¾{ğ•Štypeâ€¿nameâ€¿desc:âŸ¨
        "    {"
        "      ""type"": """âˆ¾typeâˆ¾""","
        "      ""name"": """âˆ¾nameâˆ¾""","
        "      ""description"": """âˆ¾descâˆ¾'"'
        "    },"
    âŸ©}Â¨aliases
    â‹ˆ"  ],"

    # Print enums info
    â‹ˆ"  ""enums"": ["
    Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âˆ¾{ğ•Šnameâ€¿descâ€¿values:
        âˆ¾âŸ¨
            â‹ˆ"    {"
            â‹ˆ"      ""name"": """âˆ¾nameâˆ¾""","
            â‹ˆ"      ""description"": """âˆ¾(EscapeBackslashes desc)âˆ¾""","
            â‹ˆ"      ""values"": ["
            Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âˆ¾{ğ•ŠvalueNameâ€¿valueâ€¿valueDesc:
                âŸ¨
                    "        {"
                    "          ""name"": """âˆ¾valueNameâˆ¾""","
                    "          ""value"": "âˆ¾valueâˆ¾","
                    "          ""description"": """âˆ¾(EscapeBackslashes valueDesc)âˆ¾'"'
                    "        },"
                âŸ©
            }Â¨values
            â‹ˆ"      ]"
            â‹ˆ"    },"
        âŸ©
    }Â¨enums
    â‹ˆ"  ],"

    # Print callbacks info
    â‹ˆ"  ""callbacks"": ["
    Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âˆ¾{ğ•Šnameâ€¿descâ€¿retTypeâ€¿paramTypesâ€¿paramNames:âˆ¾âŸ¨
        â‹ˆ"    {"
        â‹ˆ"      ""name"": """âˆ¾nameâˆ¾""","
        â‹ˆ"      ""description"": """âˆ¾(EscapeBackslashes desc)âˆ¾""",",
        â‹ˆ"      ""returnType"": """âˆ¾retTypeâˆ¾""","
        â‹ˆ"      ""params"": ["
        Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âˆ¾paramTypes{
            "        {"
            "          ""type"": """âˆ¾ğ•¨âˆ¾"""," 
            "          ""name"": """âˆ¾ğ•©âˆ¾""""  
            "        },"
        }Â¨paramNames
        â‹ˆ"      ]"
        â‹ˆ"    },"
    âŸ©}Â¨callbacks
    â‹ˆ"  ],"

    # Print functions info
    â‹ˆ"  ""functions"": ["
    Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âˆ¾{ğ•Šnameâ€¿descâ€¿retTypeâ€¿paramNamesâ€¿paramTypes: 
        âˆ¾âŸ¨
            â‹ˆ"    {"
            â‹ˆ"      ""name"": """âˆ¾nameâˆ¾""","
            â‹ˆ"      ""description"": """âˆ¾(EscapeBackslashes desc)âˆ¾""","
            â‹ˆ"      ""returnType"": """âˆ¾retTypeâˆ¾""","
            âˆ¾âŸ¨
                â‹ˆ"      ""params"": ["
                Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âˆ¾paramTypes{
                    âŸ¨
                        "        {"
                        "          ""type"": """âˆ¾ğ•¨âˆ¾""","
                        "          ""name"": """âˆ¾ğ•©âˆ¾'"'
                        "        },"
                    âŸ©
                }Â¨paramNames
                â‹ˆ"      ]"
            âŸ©
            â‹ˆ"    },"
        âŸ©
    }Â¨funcs

    â‹ˆ"  ]"
    â‹ˆ"}"
âŸ©

outFileName â€¢FLines parsedData