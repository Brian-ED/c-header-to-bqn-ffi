# Command line variables
inFileName â† "../src/raylib.h"
outFileName â† "raylib_api.txt"
apiDefine â† "RLAPI"       # Functions define (i.e. RLAPI for raylib.h, RMDEF for raymath.h, etc.)
truncAfter â† ""           # Truncate marker (i.e. "RLGL IMPLEMENTATION" for rlgl.h)

"
    raylib API parser

    This parser scans raylib.h to get API information about defines, structs, aliases, enums, callbacks and functions.
    All data is divided into pieces, usually as strings.

    CONSTRAINTS:

    This parser is specifically designed to work with raylib.h, so, it has some constraints:

     - Functions are expected as a single line with the following structure:

       <retType> <name>(<paramType[0]> <paramName[0]>, <paramType[1]> <paramName[1]>);  <desc>

       Be careful with functions broken into several lines, it breaks the process!

     - Structures are expected as several lines with the following form:

       <desc>
       typedef struct <name> {
           <fieldType[0]> <fieldName[0]>;  <fieldDesc[0]>
           <fieldType[1]> <fieldName[1]>;  <fieldDesc[1]>
           <fieldType[2]> <fieldName[2]>;  <fieldDesc[2]>
       } <name>;

     - Enums are expected as several lines with the following form:

       <desc>
       typedef enum {
           <valueName[0]> = <valueInteger[0]>, <valueDesc[0]>
           <valueName[1]>,
           <valueName[2]>, <valueDesc[2]>
           <valueName[3]>  <valueDesc[3]>
       } <name>;

       NOTE: Multiple options are supported for enums:
          - If value is not provided, (<valueInteger[i -1]> + 1) is assigned
          - Value description can be provided or not

    OTHER NOTES:

     - This parser could work with other C header files if mentioned constraints are followed.
     - This parser does not require <string.h> library, all data is parsed directly from char buffers.
**********************************************************************************************/
"
max_enum_values         â†  512 # Maximum number of enum values

If      â† {ğ•âŸğ•@}Â´                 # Also Repeat
IfElse  â† {câ€¿Tâ€¿F: câ—¶Fâ€¿T@}
While   â† {ğ•©â€¢_while_ğ•¨@}Â´          # While 1â€¿{... to run forever
DoWhile â† {ğ•@ â‹„ While ğ•¨â€¿ğ•©}Â´
For     â† {Iâ€¿Câ€¿Pâ€¿A: I@ â‹„ WhileâŸ¨C,Pâˆ˜AâŸ©}

# Switch/case statements have many variations; these are a few
Match   â† {ğ•ğ•¨}Â´
Select  â† {(âŠ‘ğ•©)â—¶(1â†“ğ•©)@}
Switch  â† {câ†âŠ‘ğ•© â‹„ [m,a]â†â‰âˆ˜â€¿2â¥Š1â†“ğ•© â‹„ (mâŠ¸âŠâŒ¾<C)â—¶a@}
Test    â† {fnâ†{Câ€¿Ağ•Še:Câ—¶Aâ€¿E}Â´ğ•©â‹„Fn@}

tabâ†9+@

#----------------------------------------------------------------------------------
# Types and Structures Definition
#----------------------------------------------------------------------------------

# Type of parsed define
âŸ¨
    unknown
    macro
    guard
    int
    int_math
    long
    long_math
    float
    float_math
    double
    double_math
    char
    string
    coloR
âŸ© â† â†•14

#----------------------------------------------------------------------------------
# Module Functions Definition
#----------------------------------------------------------------------------------

# Get data type and name from a string containing both
# NOTE: Useful to parse function parameters and struct fields
GetDataTypeAndNameâ†{ğ•ŠtypeName:#â€¿typeâ€¿name: # const char *typeName, int typeNameLen, char *type, char *name)
    oâ†@
    break â† 1
    For (kâ†â‰ typeName)â€¿{ğ•Š:breakâˆ§k>0}â€¿{ğ•Š:k-â†©1}â€¿{ğ•¤
        ('*'=kâŠ‘typeName)âˆ¨(' '=kâŠ‘typeName) âˆ§ ','â‰ typeNameâŠ‘Ëœk-1?
            breakâ†©0
            # Function name starts at this point (and ret type finishes at this point)
            oâ†©k(â†‘â‹ˆ1âŠ¸+âŠ¸â†“)typeName
        ;
        ('.'=kâŠ‘typeName) âˆ§ 3=â‰ typeName? # Handle varargs ...);
            breakâ†©0
            oâ†©"..."â€¿"args"
        ;""â€¿""
    }
    o
}

# Get comment from a line, do nothing if no comment in line
GetDescription â† {ğ•Šline: # str â†’ description (str)
    c â† 0
    descStart â† Â¯1
    lastSlash â† Â¯2
    isValid â† 0
    
    {isValid âˆ§ (descStart=Â¯1) âˆ§ ğ•©â‰ ' '?
        descStart â†© c
    ;'/'=ğ•©?
        isValid â†© lastSlash=c-1
        lastSlash â†© c
    ;@
    }Â¨line
    ""âŸ(descStartâ‰ Â¯1) (c-descStart)â†‘descStartâ†“line
}

# Compare two text strings, requires number of characters to compare
IsTextEqual{ğ•Štext1â€¿text2â€¿count:
    â‰¡Â´countâ†‘Â¨text1â€¿text2
}

# Find first text occurrence within a string
TextFindIndex â† âŠ‘Â¯1âˆ¾Ëœ/âˆ˜â·

# Get string of define type
StrDefineType â† âŠ‘âŸœâŸ¨
    "UNKNOWN"
    "GUARD"
    "MACRO"
    "INT"
    "INT_MATH"
    "LONG"
    "LONG_MATH"
    "FLOAT"
    "FLOAT_MATH"
    "DOUBLE"
    "DOUBLE_MATH"
    "CHAR"
    "STRING"
    "COLOR"
âŸ©

# Preprocess buffer to get separate lines
# NOTE: GetTextLines() also removes leading spaces/tabs
lines â† â€¢FLines inFileName

# Read struct lines
# Find structs
# starting with "typedef struct ... {" or "typedef struct ... ; \n struct ... {"
# ending with "} ... ;"
# i.e. excluding "typedef struct rAudioBuffer rAudioBuffer;" -> Typedef and forward declaration only
structLines â†/{
    [m1,m2]â†"typedef struct"â€¿"struct"(âŠ£â‰¡â‰ âŠ¸â†‘)âŒœğ•©
    m1âˆ§m2Â«âŠ¸âˆ¨<Â´âˆ˜âŠâŸœ"{;"Â¨ğ•©
} lines

# Read alias lines
# Find aliases (lines with "typedef ... ...;")
aliasLines â† ("typedef"âŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨âˆ§2=(+Â´Â¨' 'âŠ¸=>âˆ¨`Â¨âˆ˜âˆŠâŸœ";("))lines

# Read enum lines
# Read enum line
# Keep the line position in the array of lines,
# so, we can scan that position and following lines
# ignore inline enums
enumLines â† ("typedef enum {"âŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)âˆ§âˆ¨Â´âˆ˜=âŸœ';')Â¨lines

# Read function lines
# Read function line (starting with `define`, i.e. for raylib.h "RLAPI")
funcLines â† apiDefineâŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨lines

# At this point we have all raylib defines, structs, aliases, enums, callbacks, functions lines data to start parsing

# Parsing raylib data
#----------------------------------------------------------------------------------

# Define info data
defineIndicies â† {nameâ€¿typeâ€¿valueâ€¿descâ€¿isHexâ‡â†•5}

defMacro â† "#define"

CheckHex â† Â¬âˆ¨Â´âˆ˜âˆŠâŸœ"0123456789abcdefABCDEFxL.+-"

defines â† {
    linePtrs â† â†“âŸœlinesÂ¨/defMacroâŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨âˆ¨`âˆ˜âˆŠâŸœ' 'â€¿tâŠ¸/Â¨lines
    loopedOver â† linePtrs
    
    # Skip duplicates
    âˆŠâˆ˜{defineIndicies.nameâŠ‘ğ•©}âŠ¸/definesâŠ£{ğ•ŠlinePtr:
        name â† ""
        type â† 0
        value â† ""
        description â† ""
        ishex â† 0

        LS â† {âˆ¨`Â¬ğ•©âˆŠ' 'â€¿tab} # leading spacing
        nameAndArgs â† RSâŠ¸/{ğ”½defMacroâˆ¾â¼ğ”½}linePtr # Skip spaces and tabs, then defMacro, then spaces and tabs again

        # Extract name
        defineNameStart â† linePtr-â—‹â‰ nameAndArgs
        
        openBraces â† +`-Ë"()"=âŒœnameAndArgs
        
        nameLen â† defineNameEnd â† (âŒŠÂ´âˆ˜âŠâŸœ' 'â€¿tabâ‰¤Â·âŠ‘âŠâŸœ'(')â—¶âŸ¨
            1+âŠâŸœ')'
            âŒŠÂ´âŠâŸœ' 'â€¿tab
        âŸ© nameAndArgs

        nameâ€¿args â† nameLen(â†‘â‹ˆLSâŠ¸/âˆ˜â†“)nameAndArgs

        # Determine type
        {ğ•Š:typeâ†©macro}âŸâŠ¢')'=Â¯1âŠ‘name
        {ğ•Š:typeâ†©guard}âŸâŠ¢(0=â‰ args)âˆ¨'/'=âŠ‘args

        {'"'=âŠ‘args? typeâ†©string
        ;args=â—‹âŠ‘"'"? typeâ†©char
        ;"CLITERAL(Color)"â‰¡15â†‘args? typeâ†©color
        ;âŠ‘argsâŠ‘âŠ¸âˆŠ'0'+â†•10? # Parsing numbers
            isFloatâ€¿isNumberâ€¿isHex2 â† âŸ¨
                âŠ‘âˆŠâŸœ'.'
                âŠ‘âˆŠâŸœ'x'
                CheckHex
            âŸ©{ğ•ğ•©}Â¨<mâ†âˆ§`âˆ˜Â¬âˆ˜âˆŠâŸœ' 'â€¿tabâŠ¸/args
            {ğ•Š:isFloat?
                typeâ†©doubleâ€¿floatâŠ‘Ëœ'f'=Â¯1âŠ‘m
            ;
                typeâ†©intâ€¿longâŠ‘Ëœ'L'=Â¯1âŠ‘m
                ishexâ†©isHex2
            }âŸâŠ¢isNumber
        }

        # Extracting value
        fullValue â† âˆ¨`âŒ¾âŒ½âˆ˜Â¬âˆ˜âˆŠâŸœtabâ€¿' 'âŠ¸/args/ËœÂ¬âˆ¨`0âˆ¾Ëœ"//"â·args
        value2 â† fullValueâ†“Ëœ-âŠ‘typeâˆŠlongâ€¿float # Remove number postfix
        
        valueâ†©value2

        # Extracting description
        desc2 â† â€¢Show âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/argsâ†“Ëœ2+âŠ‘/"//"â·args
        descâ†©desc2

        # Parse defines of type UNKNOWN to find calculated numbers
        breakHappenedâ†0â¥ŠËœâ‰ value
        {ğ•¤
            largestType â† unknown
            isMath â† 1

            For (câ†0)â€¿{ğ•Š:c<â‰ valuePtr}â€¿{ğ•Š:c+â†©1}â€¿{ğ•¤
                ch â† câŠ‘valuePtr

                # Skip operators and whitespace
                {ğ•¤
                    # Read number operand
                    âˆ¨Â´ch="0123456789"?
                    isNumberâ€¿isFloat â† 1â€¿0
                    break2 â† 1
                    {ğ•¤
                        {ğ•Š:isFloatâ†©1}âŸâŠ¢ch='.'
                        {ğ•Š:isNumberâ†©0â‹„break2â†©0}âŸCheckHex ch
                        {ğ•¤
                            c+â†©1
                            châ†©câŠ‘valuePtr
                        }âŸ{ğ•Š:break2}@
                    }â€¢_while_{ğ•Š:break2âˆ§Â¬âˆ¨Â´ch="()*/ "âˆ¾@âˆ¾tab}@
                    Â¬â—¶{ğ•¤
                        # Found a valid number -> update largestType
                        numberType â† (Â¬isFloat)â—¶âŸ¨
                            DOUBLE_MATHâ€¿FLOAT_MATH âŠ‘Ëœ'f'=âŠ¢
                            INT_MATHâ€¿LONG_MATH âŠ‘Ëœ'L'=âŠ¢
                        âŸ© valuePtrâŠ‘Ëœc-1
                        {ğ•Š:largestTypeâ†©numberType}âŸâŠ¢ numberType>largestType
                    }â€¿{ğ•¤
                        isMathâ†©0
                    } isNumber
                    ;
                    # Read string operand
                    operandStart â† c
                    {ğ•Š:c+â†©1â‹„châ†©câŠ‘valuePtr}â€¢_while_{ğ•Š:Â¬âˆ¨Â´ch=" ()+-*/"âˆ¾@}@
                    operandEnd â† c
                    operandLength â† operandEnd-operandStart

                    # Search previous defines for operand
                    foundOperand â† 0
                    break1 â† 1
                    For (previousDefineIndexâ†0)â€¿{ğ•Š:breakâˆ§previousDefineIndex<defineIndex}â€¿{ğ•Š:previousDefineIndex+â†©1}â€¿{ğ•¤
                        defines[previousDefineIndex].name â‰¡â—‹(operandLengthâŠ¸â†‘) operandStartâ†“valuePtr?
                            break1â†©0
                            (â‰¥âŸœintâˆ§â‰¤âŸœdouble_math) defines[previousDefineIndex].type?
                                # Found operand and it's a number -> update largestType
                                largestType âŒˆâ†© defines[previousDefineIndex].type
                                foundOperand â† 1
                    }
                    {ğ•Š:isMathâ†©0}âŸÂ¬foundOperand
                }âŸÂ¬âˆ¨Â´ch="()+-*/ "âˆ¾tab
            }
            {ğ•¤
                # Define is a calculated number -> update type
                largestType â†© {
                    ğ•© = int    ? int_math
                    ğ•© = long   ? long_math
                    ğ•© = float  ? float_math
                    ğ•© = double ? double_math
                } largestType
                defineOut.type â† largestType
            }âŸâŠ¢isMath
        }âŸâŠ¢defineOut.type=unknown

        nameâ€¿typeâ€¿valueâ€¿descriptionâ€¿ishex
    }Â¨loopedOver
}

# Structs info data
structs â† {ğ•¤
    nameâ†""
    descâ†""
    fieldCountâ†âŸ¨âŸ©
    fieldTypeâ†""
    fieldNameâ†""
    fieldDescâ†""

    linesPtr â† ğ•©â†“lines

    # Parse struct description
    desc â†© GetDescription Â¯1âŠ‘linesPtr

    # Get struct name: typedef struct name {
    tds_len â† â‰ "typedef struct "
    breakâ†1
    For (câ†tds_len)â€¿{ğ•Š:breakâˆ§c<64+tds_len}â€¿{ğ•Š:c+â†©1}â€¿{ğ•¤
        âˆ¨Â´" {"=câŠ‘âŠ‘linesPtr?
            nameLen â† c - tds_len
            {ğ•Š:nameLen-â†©1}â€¢_while_{ğ•Š:' '=linesPtr[0][tds_len + nameLen - 1]}@
            name â†© nameLenâ†‘tds_lenâ†“0âŠ‘linesPtr
            breakâ†©0
    }

    # Get struct fields and count them -> fields finish with ;
    l â† 1
    {
        # WARNING: Some structs have empty spaces and comments -> OK, processed
        {ğ•¤
            # Scan one field line
            fieldLine â† lâŠ‘linesPtr
            fieldEndPos â† âŠ‘fieldLineâŠ';'

            {ğ•¤ # Field line is not a comment and not a struct declaration
                # Get struct field type and name
                fieldType[fieldCount] â€¿ fieldName[fieldCount] â† GetDataTypeAndName fieldEndPosâ†‘fieldLine

                # Get the field description
                fieldDesc[fieldCount] â†© GetDescription fieldEndPosâ†“fieldLine

                fieldCount+â†©1

                # Split field names containing multiple fields (like Matrix)
                additionalFields â† 0
                originalIndex â† fieldCount - 1
                For (câ†0)â€¿{ğ•Š:c<â‰ fieldName[originalIndex]}â€¿{ğ•Š:c+â†©1}â€¿{
                    {ğ•Š:additionalFields+â†©1}âŸâŠ¢fieldName[originalIndex][c] = ','
                }

                {ğ•¤
                    int originalLength â† Â¯1
                    lastStartâ†0
                    For (câ†0)â€¿{ğ•Š:c < 1+â‰ fieldName[originalIndex]}â€¿{ğ•Š:c+â†©1}â€¿{ğ•¤
                        v â† fieldName[originalIndex][c]
                        isEndOfString â† v = @
                        {ğ•¤
                            {
                                originalLength=Â¯1?
                                    # Save length of original field name
                                    # Don't truncate yet, still needed for copying
                                    originalLength â†© c
                                ;
                                # Copy field data from original field
                                nameLength â† c-lastStart
                                fieldName[fieldCount] â†© nameLength â†‘ fieldName[originalIndex][lastStart]
                                fieldType[fieldCount] â†© fieldType[originalIndex][0]
                                fieldDesc[fieldCount] â†© fieldDesc[originalIndex][0]
                                fieldCount+â†©1
                            }
                            
                            {ğ•¤
                                # Skip comma and spaces
                                c+â†©1
                                {ğ•Š:c+â†©1}â€¢_while_{ğ•Š:' '=fieldName[originalIndex][c]}@

                                # Save position for next field
                                lastStart â†© c
                            }âŸÂ¬isEndOfString
                        }âŸâŠ¢isEndOfStringâˆ¨v=','
                    }
                    # Set length of original field to truncate the first field name
                    fieldName[originalIndex][originalLength] â†© @
                }âŸâŠ¢additionalFields>0

                # Split field types containing multiple fields (like MemNode)
                additionalFields â† 0
                originalIndex â† fieldCount - 1
                For (c = 0)â€¿{ğ•Š:c<â‰ fieldType[originalIndex]}â€¿{ğ•Š:c+â†©1}â€¿{ğ•¤
                    additionalFields+â†©fieldType[originalIndex][c] = ','
                }

                {ğ•¤
                    # Copy original name to last additional field
                    fieldCount +â†© additionalFields
                    fieldName[originalIndex + additionalFields]â†© (â‰ fieldName[originalIndex])â†‘fieldName[originalIndex][0]

                    # Copy names from type to additional fields
                    fieldsRemaining â† additionalFields
                    nameStart â† Â¯1
                    nameEnd â† Â¯1
                    For (kâ†â‰ fieldType[originalIndex])â€¿{ğ•Š:k>0}â€¿{k-â†©1}â€¿{ğ•¤
                        âˆ¨Â´"* ,"=fieldType[originalIndex][k]?
                            {ğ•¤
                                # Don't copy to last additional field
                                {ğ•¤
                                    nameStart â†© k + 1
                                    fieldName[originalIndex + fieldsRemaining] â†©(nameEnd - nameStart + 1)â†‘fieldType[originalIndex][nameStart]
                                }âŸâŠ¢fieldsRemainingâ‰ additionalFields
                                nameEnd â†© Â¯1
                                fieldsRemaining-â†©1
                            }âŸâŠ¢nameEndâ‰ Â¯1
                        ;
                            nameEnd=Â¯1? nameEnd â†© k
                        ;@
                    }

                    # Truncate original field type
                    fieldTypeLength â† nameStart
                    fieldType[originalIndex][fieldTypeLength] â†© @

                    # Set field type and description of additional fields
                    For (jâ†1)â€¿{ğ•Š:jâ‰¤additionalFields}â€¿{ğ•Š:j+â†©1}â€¿{ğ•¤
                        fieldType[originalIndex + j] â†© fieldTypeLength                       â†‘fieldType[originalIndex][0]
                        fieldDesc[originalIndex + j] â†© (â‰ fieldDesc[originalIndex])â†‘fieldDesc[originalIndex][0]
                    }
                }âŸâŠ¢additionalFields > 0
            }âŸâŠ¢âˆ§Â´"struct"â€¿"/"â‰¢Â¨6â€¿1â†‘Â¨<fieldLine
        }âŸâŠ¢âˆ§Â´' 'â€¿tabâ‰ âŠ‘lâŠ‘linesPtr

        l+â†©1
    }â€¢_while_{ğ•Š:'}'â‰ âŠ‘lâŠ‘linesPtr}@

    fieldType[j] â† âŸ¨âŸ©

    # Move array sizes from name to type
    For (jâ†0)â€¿{ğ•Š:j < fieldCount}â€¿{ğ•Š:j+â†©1}â€¿{
        # Move array size from name to type
        fieldType[j] âˆ¾âŸœ<â†© 1â†“Â¯1â†“âˆ¨`âˆ˜=âŸœ'['âŠ¸/ fieldName[j]
    }
    nameâ€¿descâ€¿fieldCountâ€¿fieldTypeâ€¿fieldNameâ€¿fieldDesc
}Â¨structLines

# Alias info data
aliases â† {ğ•¤
    typeâ†"" # Alias type
    nameâ†"" # Alias name
    descâ†"" # Alias description

    # Description from previous line

    linePtr â† ğ•©âŠ‘lines

    c â† â‰ "typedef "

    # Type
    typeStart â† c
    {ğ•Š:c+â†©1}â€¢_while_{ğ•Š:' 'â‰ câŠ‘linePtr}@
    typeLen â† c - typeStart
    type â†© typeLenâ†‘typeStartâ†“linePtr

    # Skip space
    c+â†©â‰ " "

    # Name
    nameStart â† c
    {ğ•Š:c+â†©1}â€¢_while_{ğ•Š:';'â‰ câŠ‘linePtr}@
    nameLen â† c - nameStart
    nameâ†©nameLenâ†‘nameStartâ†“linePtr

    # Description
    desc âŠ£âŸ(""âŠ¸â‰¡)â†© GetDescription linesâŠ‘Ëœğ•©-1
    desc â†© GetDescription câŠ‘linePtr
    typeâ€¿nameâ€¿desc
}Â¨aliaslines

enums â† {
    name         â† ""
    desc         â† ""
    valueCount   â† âŸ¨âŸ©
    valueName    â† ""
    valueInteger â† âŸ¨âŸ©
    valueDesc    â† ""

    # Parse enum description
    # NOTE: This is not necessarily from the line immediately before,
    # some of the enums have extra lines between the "description"
    # and the typedef enum
    break â† 1
    For (jâ†ğ•©-1)â€¿{ğ•Š:breakâˆ§j > 0}â€¿{ğ•Š:j-â†©1}â€¿{ğ•¤
        linePtr â† jâŠ‘lines
        {ğ•¤
            desc â†© GetDescription linesâŠ‘Ëœj+1
            breakâ†©0
        }âŸâŠ¢('/'â‰ âŠ‘linePtr) âˆ¨ ' 'â‰ 2âŠ‘linePtr
    }
    breakâ†©1
    For (j=1)â€¿{ğ•Š:breakâˆ§j<max_enum_valuesÃ—2}â€¿{ğ•Š:j+â†©1}â€¿{ğ•¤   # Maximum number of lines following enum first line
        linePtr â† linesâŠ‘Ëœj+iâŠ‘enumLines

        (â‰¥âŸœ'A'âˆ§'Z'âŠ¸â‰¥)linePtr[0]?
            # Parse enum value line, possible options:
            #ENUM_VALUE_NAME,
            #ENUM_VALUE_NAME
            #ENUM_VALUE_NAME     = 99
            #ENUM_VALUE_NAME     = 99,
            #ENUM_VALUE_NAME     = 0x00000040,   # Value description

            # We start reading the value name
            c â† 0
            {ğ•¤
                valueName[valueCount][c] â†© linePtr[c]
                c+â†©1
            }â€¢_while_{ğ•Š:âˆ§Â´(câŠ‘linePtr)â‰ ", ="âˆ¾@}@

            # After the name we can have:
            #  '='  -> value is provided
            #  ','  -> value is equal to previous + 1, there could be a description if not '\0'
            #  ' '  -> value is equal to previous + 1, there could be a description if not '\0'
            #  '\0' -> value is equal to previous + 1

            # Let's start checking if the line is not finished
            {(â‰ âŸœ','âˆ§â‰ âŸœ@)câŠ‘linePtr?
                # Two options:
                #  '='  -> value is provided
                #  ' '  -> value is equal to previous + 1, there could be a description if not '\0'
                nâ†âˆ§`'/'â‰ câ†“linePtr
                foundValue â†© âŠ‘'='âˆŠn/câ†“linePtr
                c+â†©+Â´n

                {foundValue?
                    c+â†©1+' '=linePtrâŠ‘Ëœc+1

                    # Parse integer value
                    nâ†0
                    integer â† âŸ¨âŸ©

                    {ğ•¤
                        integer[n] â†© linePtr[c]
                        c+â†©1 â‹„ n+â†©1
                    }âŸâŠ¢âˆ§Â´','â€¿' 'â€¿@â‰ câŠ‘linePtr

                    valueInteger[valueCount] â†© â€¢ParseFloat integer
                ;
                    valueInteger[valueCount] â†© 1+valueInteger[valueCount - 1]
                }
            ;
                valueInteger[valueCount] â†© 1+valueInteger[valueCount - 1]
            }

            # Parse value description
            valueDesc[valueCount] â†© GetDescription câŠ‘linePtr

            valueCount+â†©1
    ;
        linePtr[0] = '}'?
        
            # Get enum name from typedef
            c â† 0
            {ğ•¤
                name[c] â†© linePtrâŠ‘Ëœ2 + c
                c+â†©1
            }â€¢_while_{ğ•Š:';'â‰ linePtrâŠ‘Ëœ2+c}@

            breakâ†©0  # Enum ended, break for() loop
    ;@
    }
    nameâ€¿descâ€¿valueCountâ€¿valueNameâ€¿valueIntegerâ€¿valueDesc
}Â¨enumLines

callbacks â† {
    # Skip "typedef "
    c â† â‰ "typedef"

    # Return type
    retTypeStart â† c
    c+â†©+Â´âˆ§`'('â‰ câ†“ğ•©
    retTypeLen â† c-retTypeStart
    retTypeLen-â†©+Â´âˆ§`' 'â‰ âŒ½ğ•©â†‘ËœretTypeStart+retTypeLen-1
    retType â† retTypeLenâ†‘retTypeStartâ†“ğ•©

    # Skip "(*"
    c +â†© â‰ "(*"

    # Name
    nameStartâ†c
    c+â†©+Â´âˆ§`')'â‰ câ†“ğ•©
    nameLen â† c - nameStart
    name â† nameLenâ†‘nameStartâ†“ğ•©

    # Skip ")("
    c +â†© â‰ ")("

    # Params
    paramStart â† c
    breakâ†1
    
    # âŸ¨paramTypeâ€¿paramName, ...âŸ©
    [paramTypes,paramNames] â† â‰>GetDataTypeAndNameÂ¨ ',' ((âŠ¢-Ëœ+`Ã—Â¬)âˆ˜=âŠ”âŠ¢) âˆ§`âˆ˜â‰ âŸœ')'câ†“linePtr
    # Move array sizes from name to type
    paramTypesâˆ¾Â¨â†©1â†“Â¨Â¯1â†“Â¨âˆ¨`âˆ˜=âŸœ'['âŠ¸/Â¨paramNames

    # Description
    desc â† GetDescription câ†“ğ•©

    paramCountâ†â‰ paramNames
    nameâ€¿descâ€¿retTypeâ€¿paramCountâ€¿paramTypesâ€¿paramNames
}Â¨{
    # Read callback lines
    # Find callbacks (lines with "typedef ... (* ... )( ... );")
    m1â†"typedef"âŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨ğ•©
    m1âˆ§{(");"âŠ¸â‰¡Ë˜âˆ¨`âŠ¸<")("âŠ¸â‰¡Ë˜âˆ§"(*"âŠ¸â‰¡Ë˜)2â†•ğ•©}Â¨ğ•©
}âŠ¸/lines

funcsâ†{
    name       â† ""
    desc       â† ""
    retType    â† ""
    paramCount â† âŸ¨âŸ©
    paramType  â† ""
    paramName  â† ""
    paramDesc  â† ""

    linePtr â† linesâŠ‘Ëœğ•©

    funcParamsStart â† 0
    funcEnd â† 0

    # Get return type and function name from func line
    breakâ†1
    For (câ†0)â€¿{ğ•Š:breakâˆ§(c<â‰ linePtr)âˆ§(câŠ‘linePtr)â‰ 10+@}â€¿{ğ•Š:c+â†©1}â€¿{ğ•¤
        # Starts function parameters
        {ğ•¤
            funcParamsStart â†© c + 1

            # At this point we have function return type and function name
            dc â† 1+â‰ apiDefine
            funcRetTypeNameLen â† c-dc     # Substract `define` ("RLAPI " for raylib.h)
            funcRetTypeName â† funcRetTypeNameLenâ†‘dcâŠ‘linePtr

            retTypeâ€¿name â†© GetDataTypeAndName funcRetTypeNameâ€¿funcRetTypeNameLen
            breakâ†©0
        }âŸâŠ¢'('=câŠ‘linePtr
    }

    # Get parameters from func line
    breakâ†©1
    For (câ†funcParamsStart)â€¿{ğ•Š:breakâˆ§c<â‰ linePtr}â€¿{ğ•Š:c+â†©1}â€¿{
        linePtr[c] = ','?     # Starts function parameters
            # Get parameter type + name, extract info
            funcParamTypeNameLen â† c-funcParamsStart
            funcParamTypeName â† funcParamTypeNameLenâ†‘funcParamsStartâŠ‘linePtr

            paramType[paramCount] â€¿ paramName[paramCount] â† GetDataTypeAndName funcParamTypeNameâ€¿funcParamTypeNameLen

            funcParamsStart â†© c+1
            {ğ•Š:funcParamsStart +â†© 1}âŸâŠ¢' '=linePtrâŠ‘Ëœc+1
            paramCount+â†©1      # Move to next parameter

        ; linePtr[c] = ')'?

            funcEnd â† c+2

            # Check if previous word is void
            {breakâ†©0}âŸâŠ¢(Â¯4â†‘linePtr)â‰¡"void"
            break?
            # Get parameter type + name, extract info
            funcParamTypeNameLen â† c-funcParamsStart
            funcParamTypeName â† funcParamTypeNameLenâ†‘funcParamsStartâŠ‘linePtr

            paramType[paramCount] â€¿ paramName[paramCount] â† GetDataTypeAndName funcParamTypeNameâ€¿funcParamTypeNameLen

            paramCount+â†©1      # Move to next parameter
            breakâ†©0
        ;@
    }

    # Get function description
    descâ†©GetDescription funcEndâŠ‘linePtr

    paramType[j]â†âŸ¨âŸ©

    # Move array sizes from name to type
    For (jâ†0)â€¿{ğ•Š:j < paramCount}â€¿{ğ•Š:j+â†©1}â€¿{ğ•¤
        # Move array size from name to type
        paramType[j] âˆ¾âŸœ<â†© 1â†“Â¯1â†“âˆ¨`âˆ˜=âŸœ'['âŠ¸/ paramName[j]
    }
    nameâ€¿descâ€¿retTypeâ€¿paramCountâ€¿paramTypeâ€¿paramNameâ€¿paramDesc
}Â¨funcLines

# At this point, all raylib data has been parsed!
#----------------------------------------------------------------------------------
# defines[]   -> We have all the defines decomposed into pieces for further analysis
# structs[]   -> We have all the structs decomposed into pieces for further analysis
# aliases[]   -> We have all the aliases decomposed into pieces for further analysis
# enums[]     -> We have all the enums decomposed into pieces for further analysis
# callbacks[] -> We have all the callbacks decomposed into pieces for further analysis
# funcs[]     -> We have all the functions decomposed into pieces for further analysis
â€¢Out""
â€¢Out"Input file:       "âˆ¾inFileName
â€¢Out"Output file:      "âˆ¾outFileName

outFileName â€¢FLines ParsedData@