âŸ¨
  HeaderToFFI  # Read string ğ•© and optional function prefix ğ•¨, outputs metaprogrammed file as string
  ToFFI        # turns header data from ParseHeader into ffi file characters
  ParseHeader  # Read string ğ•© and optional function prefix ğ•¨, outputs header data
  ToPrettyJson # Read header data from ParseHeader and makes a pretty json file
  SetPath      # Set the path of the resulting FFI script from ToFFI
âŸ©â‡

âŸ¨ParseJSONâ‡ParseâŸ© â† â€¢Import "json.bqn"

# util functions
nl â† @+10 # newline
wnl â† @+13 # windows newline prefix
Box â† âŸ¨âŸ©âŠ¸â‰¡â—¶âŸ¨>â‹„â†•0â€¿0âŸ©âŠ¢Â»Â¨âŸœ<' 'â¥ŠËœ0âŒˆÂ´â‰ Â¨
LowerNames â† +âŸœ(32Ã—1="A["âŠ¸â‹)âŒ¾(1â†‘â‰1âŠ¢)âŸ(âŸ¨âŸ©âŠ¸â‰¢)
_MetaParse â† {âˆ¾Ë˜Â´[ğ•—,ğ•¨]{Fâ€¿wğ•Šğ•©:<wâŠ¸âˆ¾Ë˜Box Fğ•©}Ë˜â—‹â‰â†•âˆ˜0â€¿3âŸ(âŸ¨âŸ©âŠ¸â‰¡)ğ•©}

remap â† {ğ•âŒ¾âŒ½}{ğ•ğ•}Â´{(ğ•¨âŠ¸â‰¡âˆ§"*"â‰¡1â†‘âŠ£)â—¶âŸ¨â‹ˆâ‹„ğ•©â‹ˆËœ1â†“âŠ£âŸ©Â´}Â´Â¨âŸ¨
  "unsigned char"  â€¿"ustr"
  "char"           â€¿"str"
  "void"           â€¿"ptr"
  "rAudioBuffer"   â€¿"ptr"
  "rAudioProcessor"â€¿"ptr"
âŸ©
constTextâ†"const "

SwitchOrder â† {âŒ½âŒ¾((ğ•©âˆŠ'0'+â†•10)âŠ¸/)1âŠ¸âŒ½âŒ¾((ğ•©âˆŠ"[]")âŠ¸/)ğ•©}âŒ½

shortendStructNamesâ†[
  "v2"â€¿"Vector2"
  "v3"â€¿"Vector3"
  "v4"â€¿"Vector4"
]

typeMapping â† âŸ¨
  "UNKNOWN"
  "MACRO"
  "GUARD"
  "INT"
  "INT_MATH"
  "LONG"
  "LONG_MATH"
  "FLOAT"
  "FLOAT_MATH"
  "DOUBLE"
  "DOUBLE_MATH"
  "CHAR"
  "STRING"
  "COLOR"
âŸ©

typeReplacements â† â‰shortendStructNamesâˆ¾[
  # remove since they're not defined
  "ptr"â€¿"AudioCallback"
  "ptr"â€¿"LoadFileDataCallback"
  "ptr"â€¿"LoadFileTextCallback"
  "ptr"â€¿"SaveFileDataCallback"
  "ptr"â€¿"SaveFileTextCallback"
  "ptr"â€¿"TraceLogCallback"

  """f64"""â€¿"double"
  """i64"""â€¿"long"
  "f"      â€¿"float"
  "i"      â€¿"int"
  "ptr"    â€¿"..."
  "u"      â€¿"unsigned int"
  "u8"     â€¿"char"
  "u8"     â€¿"unsigned char"
  """u16"""â€¿"unsigned short"
  " "      â€¿"void"
]

SetPath â† {pathğ•Šffi:
  default â† "âŠ‘â€¢args" # defaultPathDefinition
  (âŠâŸœ1 defaultâ·ffi)(â†‘âˆ¾'"'âˆ¾pathâˆ¾'"'âˆ¾defaultâˆ¾â¼â†“)ffi
}

# turns header data from ParseHeader into ffi file characters
# ğ•¨ is an optional name mapping, used so you can rename functions and fix name collisions
#   If the resulting name collides with a already-defined name, it errors.
## Example1: ToFFI ParseHeader file.h
## Example2: [âŸ¨"bad_name"âŸ©â‹„âŸ¨"CoolName"âŸ©] ToFFI ParseHeader file.h
ToFFI â† {ğ•¨ğ•Šdata: nameMapping â† ğ•¨âŠ£â†•2â€¿0
  # TODO check validity of names in the mapping

  MapNames â† {
    [oldâ‹„new]â†nameMapping
    (newâŠËœoldâŠ¸âŠ)âŒ¾((ğ•©âˆŠold)âŠ¸/)ğ•©
  }

  mapArgTypes â† {
    [bqn,c] â† typeReplacements
    {
      cleanedâ†constTextâŠ¸âˆ¾â¼Â¨âŒ¾((constTextâŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨ğ•©)âŠ¸/)ğ•©
      [kept,removed] â† 2â€¿âˆ˜â¥Šâ‰RemapË˜(â†•0â€¿2)âˆ¾Â´âˆ¨`âˆ˜âˆŠâŸœ"[*"âŠ¸{âŸ¨âˆ¨`âŒ¾âŒ½âˆ˜â‰ âŸœ' 'âŠ¸/ğ•©/ËœÂ¬ğ•¨ â‹„ SwitchOrder ğ•¨/ğ•©âŸ©}Â¨cleaned
      replaced â† kept LowerNamesâˆ˜(MapNamesâŒ¾â‹ˆ)âˆ˜âŠ£âŸ(0âŠ¸â‰¡)Â¨(câŠkept)âŠbqnâˆ¾0
      removed {""ğ•Šğ•©:ğ•©;'"'â‰¡âŠ‘ğ•©?ğ•¨âŠ¸âˆ¾âŒ¾('"'âŠ¸âˆ¾â¼)ğ•©;'"'âˆ¾ğ•¨âˆ¾"""âˆ¾"âˆ¾ğ•©}Â¨ replaced
    }
  }

  AddRemoved â† {
    ""ğ•Šğ•©:ğ•©;
    '"'â‰¡âŠ‘ğ•©?ğ•¨âŠ¸âˆ¾âŒ¾('"'âŠ¸âˆ¾â¼)ğ•©;
    '"'âˆ¾ğ•¨âˆ¾"""âˆ¾"âˆ¾ğ•©
  }

  MapStructTypes â† {
    [bqn,c] â† typeReplacements
    cleanedâ†constTextâŠ¸âˆ¾â¼Â¨âŒ¾((constTextâŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨ğ•©)âŠ¸/)ğ•©
    [kept,removed] â† 2â€¿âˆ˜â¥Šâ‰RemapË˜(â†•0â€¿2)âˆ¾Â´âˆ¨`âˆ˜âˆŠâŸœ"[*"âŠ¸{âŸ¨âˆ¨`âŒ¾âŒ½âˆ˜â‰ âŸœ' 'âŠ¸/ğ•©/ËœÂ¬ğ•¨ â‹„ SwitchOrder ğ•¨/ğ•©âŸ©}Â¨cleaned
    replaced â† kept LowerNamesâˆ˜(MapNamesâŒ¾â‹ˆ)âˆ˜âŠ£âŸ(0âŠ¸â‰¡)Â¨(câŠkept)âŠbqnâˆ¾0
    removed AddRemovedÂ¨ replaced
  }

  MapStructNames â† {
    [bqn,c]â†â‰shortendStructNames
    ğ•©LowerNamesâˆ˜(MapNamesâŒ¾â‹ˆ)âˆ˜âŠ£âŸ(0âŠ¸â‰¡)Â¨(câŠğ•©)âŠbqnâˆ¾0
  }

  MapFuncReturnType â† {
    [bqn,c] â† typeReplacements
    cleanedâ†ğ•©â†“ËœÂ¨constTextâ‰ âŠ¸Ã—constTextâŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨ğ•©
    [kept,removed] â† 2â€¿âˆ˜â¥Šâ‰RemapË˜(â†•0â€¿2)âˆ¾Â´ âˆ¨`âˆ˜âˆŠâŸœ"[*"âŠ¸(Â¬âŠ¸/âˆ¾âŸœ" "â¼âŸ(" "â‰¡Â¯1âŠ¸â†‘)âŠ¸â‹ˆSwitchOrderâˆ˜/)Â¨cleaned
    replaced â† kept LowerNamesâˆ˜(MapNamesâŒ¾â‹ˆ)âˆ˜âŠ£âŸ(0âŠ¸â‰¡)Â¨(câŠkept)âŠbqnâˆ¾0
    {'('âˆ¾ğ•©âˆ¾')'}âŸ(âˆ¨Â´"âˆ¾âŠ£"âŠ¸âˆŠ)Â¨"ptrâŠ£"âŠ¸âˆ¾âŸ(("ustr"â‰¡Â¯4âŠ¸â†‘)âˆ¨"str"â‰¡Â¯3âŠ¸â†‘)Â¨ removed AddRemovedÂ¨ replaced
  }

  definesâ€¿structsâ€¿aliasesâ€¿enumsâ€¿callbacksâ€¿functionsâ†{
    !ğ•©âŠ£ËâŠ¸â‰¡"defines"â€¿"structs"â€¿"aliases"â€¿"enums"â€¿"callbacks"â€¿"functions"
    âŠ¢ËÂ¨Â¨âŒ¾(0â€¿1â€¿3â€¿4â€¿5âŠ¸âŠ)âŠ¢Ëğ•©
  } ParseJSON ToPrettyJson data

  top â† 1â†“âˆ¾nlâˆ¾Â¨âŸ¨
    "#### THIS TEXT HAS BEEN AUTOGENERATED ####"
    ""
    â€¢FChars "setupMacro.bqn"
  âŸ©

  definesDone â† {
    exclTypes  â† "GUARD"â€¿"MACRO"â€¿"UNKNOWN"â€¿"FLOAT_MATH"â€¿"COLOR"
    filtered â† {ğ•Šnameâ€¿typeâ€¿valâ€¿desc:
      Â¬(âŸ¨âŸ©â‰¡val)âˆ¨Â´typeâŠ¸â‰¡Â¨exclTypes
    }Ë˜âŠ¸/(â†•0â€¿4)âˆ¾Â´defines
    "Multiple defines(#define) have the same name"!âˆ§Â´âˆŠâŠâ‰filtered
    <Ë˜""â€¿""â€¿" â‡ "â€¿" # "âŸ¨LowerNamesÂ¨MapNames,âŸ¨âŸ©Â¨,â€¢ReprÂ¨,âŠ¢âŸ©_MetaParse filtered
  }

  enumsDone â† {
    [names,descriptions,values]â†â‰(â†•0â€¿3)âˆ¾Â´enums
    tabled â†((â†•0â€¿3)âˆ¾Â´âŠ¢ËÂ¨)Â¨ values
    bodys â† (<Ë˜"  "â€¿" â‡ "â€¿"  # "âŸ¨LowerNamesÂ¨MapNames,â€¢ReprÂ¨,âŠ¢âŸ©_MetaParseâŠ¢)Â¨tabled
    headers â† (MapNames names) LowerNamesâŠ¸âˆ¾Â¨<Ë˜" â‡ { # "âŠ¸âˆ¾Ë˜Box descriptions
    âŸ¨âŸ©âˆ¾Â´headers<âŠ¸âˆ¾Â¨âˆ¾âŸœâŸ¨"}"âŸ©Â¨bodys
  }

  structsDone â† {
    [names,descriptions,fields]â†â‰(â†•0â€¿3)âˆ¾Â´structs
    headers â† (MapStructNames names) âˆ¾âŸœ" â‡ âŸ¨ # "âŠ¸âˆ¾Â¨ descriptions
    bodys â† {âŸ¨"âŸ©"âŸ©âˆ¾Ëœ<Ë˜"  "â€¿" # "â€¿"  # "âŸ¨MapStructTypes,âŠ¢,âŠ¢âŸ©_MetaParse (â†•0â€¿3)âˆ¾Â´ğ•©}Â¨âŠ¢ËÂ¨Â¨fields
    assembled â† headers <âŠ¸âˆ¾Â¨ bodys
    aliasLinesâ†Â»âŠ¸âˆ¨âˆ˜â‰ âŸœ' 'âŠ¸/Â¨<Ë˜""â€¿" â‡ "â€¿" # "âŸ¨LowerNamesÂ¨MapNames,MapArgTypes,âŠ¢âŸ©_MetaParse 1â€¿0â€¿2âŠ¸âŠË˜(â†•0â€¿3)âˆ¾Â´âŠ¢ËÂ¨aliases
    pâ†âŠ‘Â¨âŠ¢ËÂ¨aliases
    "Multiple structs and/or struct aliases have the same name"!âˆ§Â´âˆŠnamesâˆ¾1âŠ¸âŠË˜(â†•0â€¿3)âˆ¾Â´âŠ¢ËÂ¨aliases
    âˆ¾ âˆ¾âˆ¾âŸœ(<â‹ˆ)Â¨âŸœaliasLinesâŒ¾(Â¯1âŠ¸â†“)assembledâŠ”Ëœ+`Â»+Ëpâ‰¡âŒœnames
  }

  functionsDone â† {
    s â† {
      ((âŠ‘'*'âŠ¸âˆŠ)Â¨âˆ§constTextâŠ¸(âŠ£â‰¢â‰ âŠ¸â†‘)Â¨)1â€¿0âŠ¸âŠ‘Â¨Â¯1âŠ‘ğ•©
    }Â¨âˆ¾âŸœâŸ¨âŸ¨âŸ©âŸ©âŸ(3=â‰ )Â¨functions
    sLinesâ†âˆ¨Â´Â¨s

    s2 â† {
      "const void *"âŠ¸â‰¡Â¨1â€¿0âŠ¸âŠ‘Â¨Â¯1âŠ‘ğ•©
    }Â¨âˆ¾âŸœâŸ¨âŸ¨âŸ©âŸ©âŸ(3=â‰ )Â¨functions
    s2Linesâ†âˆ¨Â´Â¨s2
    !âˆ§Â´Â¬s2Linesâˆ§sLines # I don't want the lines to collide

    sAllLinesExtended â† (â†•âˆ˜â‰ âŠ¸+âŒ¾/â†‘Ëœ+Â´+â‰ )s2Linesâˆ¨sLines
    s1LinesExtendedâ€¿s2LinesExtended â† s2Lines{((+Â´+â‰ )ğ•©+ğ•¨)â†‘ğ•¨âŠ¸{(Â¬ğ•©âˆŠ/ğ•¨)/ğ•©+â†•â‰ ğ•©}âŒ¾/ğ•¨+ğ•©}{ğ”½â‹ˆğ”½Ëœ}sLines
    MakeConstDistinct â† (sAllLinesExtendedÂ¬âŠ¸Ã—(1+s2Linesâˆ¨sLines)/s+2Ã—s2){'âŸ©'âˆ¾Ëœ1â†“âˆ¾'â‹„'âˆ¾Â¨(âŠ‘"ptr"â€¿"ustr"â€¿"str"âŠ<)â—¶âŸ¨"""&u8"""â‹„"""&u8"""â‹„"""&u8:c8"""â‹„"""&"âŠ¸âˆ¾"""*"âŠ¸âˆ¾â¼âŸ©Â¨âŒ¾((1=ğ•¨)âŠ¸/)"""*i8"""Â¨âŒ¾((2=ğ•¨)âŠ¸/)ğ•©}Â¨âŠ¢

    <Ë˜""â€¿" â‡ "â€¿""""â€¿" _RâŸ¨"â€¿"#"â€¿" # "âŸ¨
      âˆ¾âŸœ"Raw"Â¨âŒ¾((Â»s2LinesExtended)âŠ¸/)Â·âˆ¾âŸœ"Ref"Â¨âŒ¾((Â»s1LinesExtended)âŠ¸/)LowerNamesÂ¨âˆ˜MapNames â‹„ MapFuncReturnType â‹„ âˆ¾âŸœ'"'Â¨ â‹„ MakeConstDistinct MapArgTypesÂ¨ â‹„ (âˆ¾' 'âŠ¸âˆ¾Â¨)Â¨ â‹„ âŠ¢
    âŸ©_MetaParseâŸ(âŸ¨âŸ©âŠ¸â‰¢){
      0â€¿2â€¿0â€¿3â€¿4â€¿1âŠ(3â†‘ğ•©)âˆ¾â‰{<Ë˜â‰(â†•0â€¿2)âˆ¾Â´âŠ¢ËÂ¨<â¼ğ•©}Ë˜âŠ¢Ëğ•©
    }âŒ¾â‰âŸ(âŸ¨âŸ©âŠ¸â‰¢)(1+s2Linesâˆ¨sLines)/(â†•0â€¿4)âˆ¾Â´âˆ¾âŸœâŸ¨âŸ¨âŸ©âŸ©âŸ(3=â‰ )Â¨functions
  }

  nlâˆ¾Ëœtopâˆ¾âˆ¾nlâˆ¾Â¨âˆ¨`âŒ¾âŒ½âˆ˜â‰ âŸœ' 'âŠ¸/Â¨âˆ¾1â†“âˆ¾âŸ¨""âŸ©âŠ¸â‹ˆÂ¨definesDoneâ€¿enumsDoneâ€¿structsDoneâ€¿functionsDone
}

# Type of parsed define
âŸ¨
  unknown
  macro
  guard
  int
  int_math
  long
  long_math
  float
  float_math
  double
  double_math
  char
  string
  color
âŸ© â† â†•14

# Get data type and name from a string containing both
# NOTE: Useful to parse function parameters and struct fields
GetDataTypeAndName â† (âˆ¨`âŒ¾âŒ½âˆŠâŸœ"* ">âˆ¨`âˆ˜=âŸœ',')âŠ¸(/â‹ˆÂ¬âŠ¸/) # typeâ€¿name: # const char *typeName, int typeNameLen, char *type, char *name)

# Get comment from a line, do nothing if no comment in line
GetDescription â† âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/2â†“âˆ¨`âˆ˜âˆ§âŸœÂ«âˆ˜=âŸœ'/'âŠ¸/ # str â†’ description (str)

defMacro â† "#define"

# Reads list of characters ğ•© (headerChars) that represent a header file.
# Optional ğ•¨ (definePrefix), needed if you want to parse functions. It's the function prefix of choice.
# Outputs header data.
# Example1: "RLAPI" ParseHeader â€¢FChars "file-name.h"
# Example2: ParseHeader â€¢FChars "other-file.h"
ParseHeader â† {ğ•¨ğ•ŠheaderChars:
  SingleLineComments â† {0{ğ•¨ğ•Š0â€¿0:ğ•¨;1âŠ‘ğ•©}`(nl=ğ•©) â‹ˆÂ¨ âˆ§âŸœÂ«'/'=ğ•©}
  MultiLineComments â† {((/0â‰ 0âˆ¾d)!0=+Â´d)âŠ¢0â‰ +`dâ†-Ë"/*"â€¿"*/"â‰¡âŒœğ•©}
  LinesToChars â† {ğ•Šâ¼: (+`Ã—Â¬)âŠ¸-âˆ˜=âŸœnlâŠ¸âŠ”ğ•©; 1â†“""âˆ¾Â´nlâˆ¾Â¨ğ•©}
  # Example:
  # ğ•¨ â† "RLAPI" # Functions define (i.e. RLAPI for raylib.h)
  definePrefix â† ğ•¨âŠ£"NO_FUNCTIONS"

  headerLines â† nl((+`Ã—Â¬)âŠ¸-âˆ˜=âŠ”âŠ¢) wnlâŠ¸â‰ âŠ¸/ headerChars

  lines â† ' 'âŸ((9+@)âŠ¸â‰¡)Â¨Â¨ headerLines

  defines â† (âˆŠâŠ‘Â¨)âŠ¸/ Â¯1âŠ‘Â¨{lastDefinesğ•Šğ•©: defineLineâ†âŠ‘ğ•©
    nameâ€¿args â† defineLine {ğ•ğ•©}Â´âŒ½âŸ¨
      (âˆ¨`âˆ§âˆ¨`âŒ¾âŒ½)âˆ˜(âˆ§`âˆ˜âˆ¨âŸœÂ«âŠ¸âˆ§Ë"/ "â‰ âŒœâŠ¢)âŠ¸/
      defMacroâŠ¸âˆ¾â¼ # Skip defMacro
      âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/ # skip spaces
      â‰¤Â´âˆ˜âŠâŸœ" ("â—¶âŸ¨1+âŠâŸœ')' â‹„ âŠâŸœ' 'âŸ©âŠ¸(â†‘â‹ˆâˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/âˆ˜â†“) # nameâ€¿args
    âŸ©
    # Determine type
    ishex â† 0
    type â† {
      """"â‰¡1â†‘args?
        string
    ;
      "'"â‰¡1â†‘args?
        char
    ;
      "CLITERAL(Color)"(âŠ£â‰¡â‰ âŠ¸â†‘)args?
        color
    ;
      âŠ‘"0123456789"âˆŠËœ1â†‘args?
        chars â† âˆ§`âˆ˜â‰ âŸœ' 'âŠ¸/args # up to first space
        isHex â†© âˆ¨Â´'x'=chars
        {ğ•¤
          âˆ¨Â´'.'=chars?
            doubleâ€¿floatâŠ‘Ëœ'f'=ğ•©
        ;
          intâ€¿longâŠ‘Ëœ'L'=ğ•©
        }âŠ‘Â¬âˆ˜Â«âˆ˜âˆŠâŸœ"0123456789xL.+-ABCDEFabcdef"âŠ¸/chars
    ;
      type â† unknownâ€¿macroâŠ‘Ëœ")"â‰¡Â¯1â†‘name
      typeâ€¿guardâŠ‘Ëœ0=â‰ args
    }
    # Extracting value
    value â† argsâ†“Ëœ-âŠ‘typeâˆŠlongâ€¿float # Remove number postfix

    # Extracting description
    description â† GetDescription defineLine

    # Parse defines of type UNKNOWN to find calculated numbers
    {ğ•¤
      numberLetters â† "0123456789xL.+-abcdefABCDEF"
      numbers â† (Â¬-ËœâŠ¢Ã—Â·+`Â»âŠ¸>)âˆ˜âˆŠâŸœ"0123456789."âŠ¸âŠ” value
      operands â† (Â¬-ËœâŠ¢Ã—Â·+`Â»âŠ¸>)âˆ˜âˆŠâŸœ"()+-*/ "âŠ¸âŠ” value

      numTypes â† âŸ¨
        int
        int_math
        long
        long_math
        float
        float_math
        double
        double_math
      âŸ©
      # Search previous defines for operand
      # Found operand and it's a number -> update type
      [names,types] â† â‰(â†•0â€¿2)âˆ¾Â´2â†‘Â¨lastDefines

      areNums â† numTypesâˆŠËœtypeMappingâŠtypes
      type âŒˆÂ´â†© {âŒˆÂ´types/ËœareNumsâˆ§ğ•©}Ë˜operandsâ‰¡âŒœnames

      areNumbers â† âˆ§Â´âˆ˜âˆŠâŸœ"0123456789xL.+-abcdefABCDEF"Â¨numbers
      isMathâ†âˆ§Â´areNumbers

      # Read number operand
      # Found a valid number -> update largestType
      type âŒˆÂ´â†© {
        isFloatâ†âˆ¨Â´('.'=ğ•©)âˆ§âˆ§`ğ•©âˆŠ"0123456789abcdefABCDEFxL.+-"
        [
          long_mathâ€¿int_math
          float_mathâ€¿double_math
        ]âŠ‘ËœisFloat(âŠ£â‹ˆâŠ‘)"Lf"=âŠ‘ğ•©
      }Â¨areNumbers/numbers

      # Search previous defines for operand
      # Found operand and it's a number -> update type
      foundOperands â† {
        (âˆ§`â‰¥âŸœintâˆ§â‰¤âŸœdouble_math)âŠ¸/ğ•©âŠ¸â‰¡Â¨âŠ¸/Ëâ‰(â†•0â€¿2)âˆ¾Â´2â†‘Â¨lastDefines
      }Â¨operands

      typeâŒˆÂ´â†©âŒˆÂ´Â¨foundOperands
      isMathâˆ§Â´â†©0<â‰ Â¨foundOperands

      {ğ•¤
        # Define is a calculated number -> update type
        mathTypes â† int_mathâ€¿long_mathâ€¿float_mathâ€¿double_mathâ€¿type
        typeâ†©mathTypesâŠ‘ËœâŠ‘intâ€¿longâ€¿floatâ€¿doubleâŠtype
      }âŸâŠ¢isMath
    }âŸâŠ¢type=unknown
    lastNamesâ†âŠ‘Â¨lastDefines
    value {'-'âŸ('Â¯'âŠ¸â‰¡)Â¨â€¢Repr 16âŠ¸Ã—âŠ¸+ËœÂ´âŒ½(âˆ¾"0A"+âŸœâ†•Â¨10â€¿6)âŠ-âŸœ(32Ã—1="a{"âŠ¸â‹)"0x"âˆ¾â¼ğ•©}âŸishexâ†©
    value {
      âˆ¨Â´type=intâ€¿longâ€¿floatâ€¿double?
        ğ•©
    ;
      type = string?
        ğ•©
    ;
      '"'âˆ¾ğ•©âˆ¾'"'
    }â†©

    ğ•¨ âˆ¾âŸœ< nameâ€¿(typeâŠ‘typeMapping)â€¿valueâ€¿description
  }`Â´(<âŸ¨âŸ©)â‹ˆâ†“âŸœlinesÂ¨/defMacroâŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/Â¨ {""Â¨âŒ¾((MultiLineCommentsğ•©)âŠ¸/)ğ•©} Â¬âˆ˜SingleLineCommentsâŠ¸/âŒ¾LinesToChars lines

  # Structs info data
  structs â† (âŠ‘Â¨Â¬âŠ¸/1âŠ¸âŠ‘Â¨){ğ•¤
    structLines â† âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/Â¨ğ•©â†“lines
    desc â† GetDescription (ğ•©-1)âŠ‘lines # Parse struct description
    nameâ†' 'âŠ¸â‰ âŠ¸/âˆ§`âˆ˜â‰ âŸœ'{'âŠ¸/"struct "âˆ¾â¼"typedef "(âŠ¢â†“Ëœâ‰ âˆ˜âŠ£Ã—âŠ£â‰¡â‰ âŠ¸â†‘)âŠ‘structLines # Get struct name: typedef struct name {
    skipMe â† (âŸ¨âŸ©â‰¡name)âˆ¨Â¬âˆ§Â´nameâˆŠâˆ¾'_'âˆ¾"aA0"+â†•Â¨26â€¿26â€¿10
    â€¢OutâŸskipMe "Warning: struct skipped with name """âˆ¾nameâˆ¾""". Struct name invalid."
    fieldLines â† (âˆ§Ë"/ "â‰ âŒœ' 'âŠ£Â´Â¨âŠ¢)âŠ¸/âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/Â¨(âˆ§`'}'â‰ ' 'âŠ£Â´Â¨âŠ¢)âŠ¸/1â†“structLines
    Warningâ†{ğ•©âŠ£â€¢Out {âˆ§Â´nameâˆŠâˆ¾"aA0"+â†•Â¨26â€¿26â€¿10?ğ•¨âˆ¾" named "âˆ¾ğ•©âˆ¾Ëœâ€¢Repr name;ğ•¨âˆ¾ğ•©}Â´ "Warning: struct"â€¿" skipped. Structs or enums in struct fields are not allowed. Nested structs will likely be skipped due to empty prefix names."}
    skipMe âˆ¨â†© WarningâŸâŠ¢ âˆ¨Â´âˆ¨Ë"struct"â€¿"enum"(â‰¡âŒœâˆ¨âˆ¾Â¨âŸœ' '(âŠ£â‰¡7â†‘âŠ¢)âŒœâŠ¢)fieldLines

    fields â† âˆ¾Â´{ # Get struct fields and count them -> fields finish with ;
      fieldTypeâ€¿fieldNamesUnparsed â† âˆ¨`âŒ¾âŒ½âˆ˜â‰ âŸœ' 'âŠ¸/Â¨ GetDataTypeAndName âŠâŸœ';'âŠ¸â†‘ğ•©
      fieldNames â† âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/Â¨ ','((âŠ¢-Ëœ+`Ã—Â¬)âˆ˜=âŠ”âŠ¢)fieldNamesUnparsed # "m0, m4, m8, m12"
      fieldDesc  â† GetDescription ğ•©

      # Move type len info from name to type
      fieldTypes â† fieldTypeâŠ¸âˆ¾Â¨âˆ¨`âˆ˜=âŸœ'['âŠ¸/Â¨fieldnames
      fieldnames âˆ§`âˆ˜â‰ âŸœ'['âŠ¸/Â¨â†©

      fieldTypesNonRecursive â† {"ptr"Â¨âŒ¾((nameâŠ¸â‰¡Â¨âˆ§`âˆ˜Â¬âˆ˜âˆŠâŸœ"* "âŠ¸/Â¨ğ•©)âŠ¸/)ğ•©}fieldTypes
      (<fieldDesc)âŠ¸âˆ¾Â¨fieldTypesNonRecursiveâ‹ˆÂ¨fieldNames
    }Â¨fieldLines

    âŸ¨skipMeâ‹„nameâ€¿descâ€¿fieldsâŸ©

    # Read struct lines
    # Find structs
    # starting with "typedef struct ... {" or "typedef struct ... ; \n struct ... {"
    # ending with "} ... ;"
    # i.e. excluding "typedef struct rAudioBuffer rAudioBuffer;" -> Typedef and forward declaration only
  }Â¨/{
    [m1,m2]â†"typedef struct"â€¿"struct"(âŠ£â‰¡â‰ âŠ¸â†‘)âŒœ âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/Â¨ğ•©
    m2âˆ¨m1âˆ§m2 0âŠ¸Â«âŠ¸âˆ¨<Â´âˆ˜âŠâŸœ"{;"Â¨ğ•©
  } {""Â¨âŒ¾((MultiLineCommentsğ•©)âŠ¸/)ğ•©} Â¬âˆ˜SingleLineCommentsâŠ¸/âŒ¾LinesToChars lines

  # Alias info data
  aliases â† {ğ•¤
    aliasLine â† ğ•©âŠ‘lines
    desc â† (linesâŠ‘Ëœğ•©-1)âŠ£âŸ(""âŠ¸â‰¡)â—‹GetDescription aliasLine
    typeâ€¿name â† ' '((Â¬-ËœâŠ¢Ã—Â·+`Â»âŠ¸>)âˆ˜â‰ âŠ”âŠ¢)"typedef "âˆ¾â¼âŠâŸœ'/'âŠ¸â†‘aliasLine
    name âˆ¾âŸœ";"â¼â†©
    typeâ€¿nameâ€¿desc
  }Â¨/(âˆ¨Â´âˆ˜=âŸœ';'âˆ§"typedef"âŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)âˆ§2=(+Â´' 'âŠ¸=>âˆ¨`âˆ˜=âŸœ';'))Â¨lines # Find aliases (lines with "typedef ... ...;")

  enums â† {
    # Parse enum description
    # NOTE: This is not necessarily from the line immediately before,
    # some of the enums have extra lines between the "description"
    # and the typedef enum
    desc â† GetDescription âŸ¨âŸ©âŠ¸â‰¡â—¶âŠ‘â€¿""(âˆ§`("// "â‰¡3âŠ¸â†‘)Â¨)âŠ¸/âŒ¾âŒ½ğ•©â†‘lines

    # Parse enum value line, possible options:
    #ENUM_VALUE_NAME,
    #ENUM_VALUE_NAME
    #ENUM_VALUE_NAME     = 99
    #ENUM_VALUE_NAME     = 99,
    #ENUM_VALUE_NAME     = 0x00000040,   # Value description
    values â† {ğ•¤
      valueInteger â† âŸ¨âŸ©

      # We start reading the value name
      valueNameâ†(âˆ§`Â·âˆ§Ë", ="â‰ âŒœâŠ¢)âŠ¸/ğ•©

      # After the name we can have:
      #  '='  -> value is provided
      #  ','  -> value is equal to previous + 1, there could be a description if not '\0'
      #  ' '  -> value is equal to previous + 1, there could be a description if not '\0'
      #  '\0' -> value is equal to previous + 1

      # Let's start checking if the line is not finished
      # Two options:
      #  '='  -> value is provided
      #  ' '  -> value is equal to previous + 1, there could be a description if not '\0'

      valuesUnparsedâ†Â¬âˆ˜âˆŠâŸœ", "âŠ¸/valueNameâˆ¾â¼âŠâŸœ'/'âŠ¸â†‘ğ•©

      value â† {"="â‰¡1â†‘ğ•©?
        {"0x"â‰¡2â†‘ğ•©?
          16âŠ¸Ã—âŠ¸+ËœÂ´âŒ½(âˆ¾"0A"+âŸœâ†•Â¨10â€¿6)âŠ-âŸœ(32Ã—1="a{"âŠ¸â‹)2â†“ğ•©
        ;
          â€¢ParseFloatğ•©
        }'='âŠ¸âˆ¾â¼ğ•©
        ;@
      } valuesUnparsed

      # Parse value description
      valueDesc â† GetDescription ğ•©

      valueNameâ€¿valueâ€¿valueDesc
    }Â¨((â‰¥âŸœ'A'âˆ§'Z'âŠ¸â‰¥)âˆ˜âŠ‘Â¨1â†‘Â¨âŠ¢)âŠ¸/ âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/Â¨(âˆ§`'}'â‰ Â·âŠ‘Â¨1â†‘Â¨âŠ¢)âŠ¸/linesâ†“Ëœ1+ğ•©

    values {ğ•©=@?ğ•¨+1;ğ•©}`âŒ¾(1âŠ¸âŠ‘Â¨)â†©
    values ('-'âŸ('Â¯'âŠ¸â‰¡)Â¨â€¢Repr)Â¨âŒ¾(1âŠ¸âŠ‘Â¨)â†©

    # Get enum name from typedef
    nameâ†"} "âˆ¾â¼âŠâŸœ';'âŠ¸â†‘ (âŠ‘âˆ˜âŠâŸœ'}'Â·âˆ¾Â´1â†‘Â¨âŠ¢)âŠ¸âŠ‘linesâ†“Ëœ1+ğ•©

    nameâ€¿descâ€¿values

    # Read enum lines
    # ignore inline enums
  }Â¨/("typedef enum {"âŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)âˆ§âˆ¨Â´âˆ˜â‰ âŸœ';')Â¨ {""Â¨âŒ¾((MultiLineCommentsğ•©)âŠ¸/)ğ•©} Â¬âˆ˜SingleLineCommentsâŠ¸/âŒ¾LinesToChars lines

  callbacks â† {
    RLS â† âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/

    # Return type
    afterDef â† RLS "typedef "âˆ¾â¼ğ•©
    retType â† RLSâŒ¾âŒ½ âŠâŸœ'('âŠ¸â†‘afterDef
    afterStar â† RLS "(*"âˆ¾â¼ RLS retTypeâˆ¾â¼RLS afterDef
    name â† RLSâŒ¾âŒ½ âŠâŸœ')'âŠ¸â†‘ afterStar
    afterName â† RLS")("âˆ¾â¼RLS nameâˆ¾â¼afterStar

    # âŸ¨paramTypeâ€¿paramName, ...âŸ©
    [paramTypes,paramNames] â† â‰>GetDataTypeAndNameÂ¨ ','((âŠ¢-Ëœ+`Ã—Â¬)âˆ˜=âŠ”âŠ¢) âŠâŸœ')'âŠ¸â†‘afterName

    # Move array sizes from name to type
    paramTypesâˆ¾Â¨â†©âŠâŸœ'['âŠ¸â†“Â¨paramNames
    paramNames âŠâŸœ'['âŠ¸â†‘Â¨â†©
    paramTypes (âˆ¨`âˆ§âˆ¨`âŒ¾âŒ½)âˆ˜â‰ âŸœ' 'âŠ¸/Â¨â†©

    # Description
    desc â† GetDescription ğ•©

    nameâ€¿descâ€¿retTypeâ€¿paramTypesâ€¿paramNames
  }Â¨{
    # Read callback lines
    # Find callbacks (lines with "typedef ... (* ... )( ... );")
    m1â†"typedef"âŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨ğ•©
    m1âˆ§{((âˆ¨Â´");"âŠ¸â‰¡Ë˜)âˆ§(âˆ¨Â´")("âŠ¸â‰¡Ë˜)âˆ§(âˆ¨Â´"(*"âŠ¸â‰¡Ë˜))2â†•" "âŸ(""âŠ¸â‰¡)ğ•©}Â¨ğ•©
  }âˆ˜{""Â¨âŒ¾((MultiLineCommentsğ•©)âŠ¸/)ğ•©}âŠ¸/lines

  functions â† {
    funcSignature â† ğ•©âˆ¾â¼ËœdefinePrefixâˆ¾' '

    retTypeâ€¿name â† GetDataTypeAndName âŠâŸœ'('âŠ¸â†‘funcSignature
    retType (âˆ¨`âˆ§âˆ¨`âŒ¾âŒ½)âˆ˜â‰ âŸœ' 'âŠ¸/â†©

    [paramTypesâ‹„paramNames]â†âŸ¨âŸ©âŠ¸â‰¢â—¶âŸ¨â†•2â€¿0â‹„â‰>âŸ©("void"â‰¢Â¯4âŠ¸â†‘)â—¶âŸ¨
      âŸ¨âŸ© â‹„ {GetDataTypeAndNameÂ¨(âˆ¨`âˆ§âˆ¨âŸœÂ«)âˆ˜â‰ âŸœ' 'âŠ¸/Â¨','((âŠ¢-Ëœ+`Ã—Â¬)âˆ˜=âŠ”âŠ¢)ğ•©}
    âŸ© âŠâŸœ')'âŠ¸â†‘(1+âŠâŸœ'(')âŠ¸â†“funcSignature

    # Move array sizes from name to type
    paramTypesâˆ¾Â¨â†©âŠâŸœ'['âŠ¸â†“Â¨paramNames
    paramTypes (âˆ¨`âˆ§âˆ¨`âŒ¾âŒ½)âˆ˜â‰ âŸœ' 'âŠ¸/Â¨â†©

    paramNames âŠâŸœ'['âŠ¸â†‘Â¨â†©

    paramTypesâ€¿paramNames {<Ë˜"..."âŠ¸â‰¡â—¶âŸ¨â‹ˆâ‹„"..."â€¿"args"âŸ©Â´Ë˜âŒ¾â‰>ğ•©}â†©

    desc â† GetDescription ğ•©

    nameâ€¿descâ€¿retTypeâ€¿paramNamesâ€¿paramTypes

    # Read function lines
    # Read function line (starting with `define`)
  }Â¨definePrefixâŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨âˆ˜{""Â¨âŒ¾((MultiLineCommentsğ•©)âŠ¸/)ğ•©}âŠ¸/lines

  definesâ€¿structsâ€¿aliasesâ€¿enumsâ€¿callbacksâ€¿functions
}

âŸ¨UnEscape, EscapeâŸ© â† {
  in â† """\/bfrnt"
  out â† (3â†‘in)âˆ¾@+8â€¿12â€¿13â€¿10â€¿9
  diff â† (out-in) âˆ¾ 0
  Basic â† {
    i â† in âŠ ğ•©
    "Unknown escape" ! âˆ§Â´ğ•¨â‰¤i<â‰ in
    ğ•© + ğ•¨ Ã— i âŠ diff
  }

  hc â† "0Aa"
  hb â† â¥Šhc+0â‰Ë˜10â€¿6â€¿6   # Hex boundaries, start and after-end
  ho â† 2/hc-0â€¿10â€¿10    # Corresponding offsets
  Hex â† { u ğ•Š ğ•©:
    d â† ğ•© /Ëœ m â† â‰ ` (4â¥Š0)âŠ¸Â»âŠ¸â‰  Â»u
    t â† hb â‹ d
    "String \u must be followed by 4 hex characters" ! âˆ§Â´1=2|t
    # Now m can't run past the end or self-intersect,
    # or it would have hit a closing quote or backslash
    v â† 16âŠ¸Ã—âŠ¸+ËœËâŒ½ â‰âˆ˜â€¿4â¥Š d-tâŠho
    wâ€¿e â† Surrogate v
    âŸ¨(w+@-'u')âŠ¸+âŒ¾(uâŠ¸/)ğ•©, eâŒ¾(uâŠ¸/)mâŸ©
  }
  sr â† 2â‹†10            # Surrogate base/radix
  sb â† srÃ—52+2+â†•3      # Surrogate character boundaries
  Surrogate â† {
    c â† (â‰ sb)|sbâ‹ğ•©     # 0 for non-surrogate, 1 then 2 for surrogate
    h â† 1=c            # First half
    "Unmatched surrogate pair" ! (0âˆ¾h) â‰¡ (2=c)âˆ¾0
    r â† ğ•© - câŠ0âˆ¾sb     # Numeric value of surrogates
    v â† r + Â»hÃ—srÃ—(2â‹†6)+r
    âŸ¨v, hâŸ©
  }

  UnEscape â‡ { e ğ•Š ğ•©:
    u â† e âˆ§ ğ•©='u'
    (u<e)âŠ¸BasicâŒ¾âŠ‘ u HexâŸœâŠ‘âŸ(âˆ¨Â´u) ğ•©â€¿0
  }

  Hex32 â† {                # Convert ğ•©<32 to two hex digits
    uâ€¿l â† 16(âŒŠâˆ˜Ã·Ëœâ‹ˆ|)ğ•©      # Upper and lower digits; âˆ§Â´u<2
    '0'+uâ‰Ë˜l-(10+-Â´"0A")Ã—10â‰¤l
  }
  Escape â‡ {
    e â† (ğ•©âˆŠ2â†‘in) âˆ¨ ğ•©<@+32  # Quote, backslash, and control characters
    j â† /e â‹„ k â† Â¬e        # Their indices; characters to keep
    c â† j âŠ ğ•©              # Characters to be escaped
    m â† c - (outâŠc)âŠdiff   # Escape the basic ones
    g â† 2 âˆ¾Ëœ m<@+32        # Group ğ•¨ to separate...
    nâ€¿u â† g âŠ” m            # Characters requiring basic, hex escapes
    i â† âˆ¾âŸ¨/kâŸ©âˆ¾2â€¿6/Â¨gâŠ”j     # Target indices
    i â‹âŠ¸âŠ âˆ¾âŸ¨               # Use them to reorder:
      k/ğ•©                  # Kept characters
      â¥Š'\'â‰Ë˜n              # Basic escapes
      â¥Š"\u00"âŠ¸âˆ¾Ë˜ Hex32 u-@ # Hex escapes
    âŸ©
  }
}

# Reads header data from ParseHeader and makes a pretty json file
ToPrettyJson â† {ğ•Šdefinesâ€¿structsâ€¿aliasesâ€¿enumsâ€¿callbacksâ€¿functions:
  EscapeBackslashesâ†âˆ¾'\'âŠ¸=â—¶â‹ˆâ€¿"\\"Â¨

  # Export parsed data in json
  1â†“âˆ¾nlâˆ¾Â¨âˆ¾âŸ¨
    â‹ˆ"{"

    # Print defines info
    â‹ˆ"  ""defines"": ["
    Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âŸ¨âŸ©âˆ¾Â´{ğ•Šnameâ€¿typeâ€¿valueâ€¿description:âŸ¨
      "    {"
      "      ""name"": """âˆ¾nameâˆ¾""","
      "      ""type"": """âˆ¾typeâˆ¾""","
      "      ""value"": "âˆ¾valueâˆ¾','
      "      ""description"": """âˆ¾(Escape description)âˆ¾""""
      "    },"
    âŸ©}Â¨defines
    â‹ˆ"  ],"
    # Print structs info
    â‹ˆ"  ""structs"": ["
    Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âŸ¨âŸ©âˆ¾Â´{ğ•Šnameâ€¿descâ€¿fields:âˆ¾âŸ¨
      â‹ˆ"    {"
      â‹ˆ"      ""name"": """âˆ¾nameâˆ¾""","
      â‹ˆ"      ""description"": """âˆ¾(Escape desc)âˆ¾""","
      â‹ˆ"      ""fields"": ["
      Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âŸ¨âŸ©âˆ¾Â´{ğ•ŠfieldDescâ€¿fieldTypeâ€¿fieldName:âŸ¨
        "        {"
        "          ""type"": """âˆ¾fieldTypeâˆ¾""","
        "          ""name"": """âˆ¾fieldNameâˆ¾""","
        "          ""description"": """âˆ¾(Escape fieldDesc)âˆ¾""""
        "        },"
      âŸ©}Â¨fields
      â‹ˆ"      ]"
      â‹ˆ"    },"
    âŸ©}Â¨structs
    â‹ˆ"  ],"

    # Print aliases info
    â‹ˆ"  ""aliases"": ["
    Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âŸ¨âŸ©âˆ¾Â´{ğ•Štypeâ€¿nameâ€¿desc:âŸ¨
      "    {"
      "      ""type"": """âˆ¾typeâˆ¾""","
      "      ""name"": """âˆ¾nameâˆ¾""","
      "      ""description"": """âˆ¾descâˆ¾'"'
      "    },"
    âŸ©}Â¨aliases
    â‹ˆ"  ],"

    # Print enums info
    â‹ˆ"  ""enums"": ["
    Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âŸ¨âŸ©âˆ¾Â´{ğ•Šnameâ€¿descâ€¿values:
      âˆ¾âŸ¨
        â‹ˆ"    {"
        â‹ˆ"      ""name"": """âˆ¾nameâˆ¾""","
        â‹ˆ"      ""description"": """âˆ¾(Escape desc)âˆ¾""","
        â‹ˆ"      ""values"": ["
        Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âŸ¨âŸ©âˆ¾Â´{ğ•ŠvalueNameâ€¿valueâ€¿valueDesc:
          âŸ¨
            "        {"
            "          ""name"": """âˆ¾valueNameâˆ¾""","
            "          ""value"": "âˆ¾valueâˆ¾","
            "          ""description"": """âˆ¾(Escape valueDesc)âˆ¾'"'
            "        },"
          âŸ©
        }Â¨values
        â‹ˆ"      ]"
        â‹ˆ"    },"
      âŸ©
    }Â¨enums
    â‹ˆ"  ],"

    # Print callbacks info
    â‹ˆ"  ""callbacks"": ["
    Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âŸ¨âŸ©âˆ¾Â´{ğ•Šnameâ€¿descâ€¿retTypeâ€¿paramTypesâ€¿paramNames:âˆ¾âŸ¨
      â‹ˆ"    {"
      â‹ˆ"      ""name"": """âˆ¾nameâˆ¾""","
      â‹ˆ"      ""description"": """âˆ¾(Escape desc)âˆ¾""",",
      â‹ˆ"      ""returnType"": """âˆ¾retTypeâˆ¾""""âˆ¾","/ËœâŸ¨âŸ©â‰¢paramTypes
      âŸ¨âŸ©âŸ(âŸ¨âŸ©â‰¡paramTypes)âˆ¾âŸ¨
        â‹ˆ"      ""params"": ["
        Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âŸ¨âŸ©âˆ¾Â´paramTypes{
          âŸ¨
            "        {"
            "          ""type"": """âˆ¾ğ•¨âˆ¾""","
            "          ""name"": """âˆ¾ğ•©âˆ¾""""
            "        },"
          âŸ©
        }Â¨paramNames
        â‹ˆ"      ]"
      âŸ©
      â‹ˆ"    },"
    âŸ©}Â¨callbacks
    â‹ˆ"  ],"

    # Print functions info
    â‹ˆ"  ""functions"": ["
    Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âŸ¨âŸ©âˆ¾Â´{ğ•Šnameâ€¿descâ€¿retTypeâ€¿paramNamesâ€¿paramTypes:
      âˆ¾âŸ¨
        â‹ˆ"    {"
        â‹ˆ"      ""name"": """âˆ¾nameâˆ¾""","
        â‹ˆ"      ""description"": """âˆ¾(Escape desc)âˆ¾""","
        â‹ˆ"      ""returnType"": """âˆ¾retTypeâˆ¾""""âˆ¾","/ËœâŸ¨âŸ©â‰¢paramTypes
        âŸ¨âŸ©âŸ(âŸ¨âŸ©â‰¡paramTypes) âˆ¾âŸ¨
          â‹ˆ"      ""params"": ["
          Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âŸ¨âŸ©âˆ¾Â´paramTypes{
            âŸ¨
              "        {"
              "          ""type"": """âˆ¾ğ•¨âˆ¾""","
              "          ""name"": """âˆ¾ğ•©âˆ¾'"'
              "        },"
            âŸ©
          }Â¨paramNames
          â‹ˆ"      ]"
        âŸ©
        â‹ˆ"    },"
      âŸ©
    }Â¨functions

    â‹ˆ"  ]"
    â‹ˆ"}"
  âŸ©
}

HeaderToFFI â† ToFFI ParseHeader
