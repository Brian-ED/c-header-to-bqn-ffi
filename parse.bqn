âŸ¨
  HeaderToFFI  # Read string ğ•© and optional function prefix ğ•¨, outputs metaprogrammed file as string
  ToFFI        # turns header data from ParseHeader into ffi file characters
  ParseHeader  # Read string ğ•© and optional function prefix ğ•¨, outputs header data
  ToPrettyJson # Read header data from ParseHeader and makes a pretty json file
âŸ©â‡

json â† â€¢Import "json.bqn"

# util functions
nl â† @+10 # newline
Box â† âŸ¨âŸ©âŠ¸â‰¡â—¶âŸ¨>â‹„â†•0â€¿0âŸ©âŠ¢Â»Â¨âŸœ<' 'â¥ŠËœ0âŒˆÂ´â‰ Â¨
LowerNames â† +âŸœ(32Ã—1="A["âŠ¸â‹)âŒ¾(1â†‘â‰1âŠ¢)âŸ(âŸ¨âŸ©âŠ¸â‰¢)
_MetaParse â† {âˆ¾Ë˜Â´[ğ•—,ğ•¨]{Fâ€¿wğ•Šğ•©:<wâŠ¸âˆ¾Ë˜Box Fğ•©}Ë˜â—‹â‰â‰âˆ˜[âŸ¨âŸ©â‹„âŸ¨âŸ©â‹„âŸ¨âŸ©]âŸ(âŸ¨âŸ©âŠ¸â‰¡)ğ•©}

remap â† {ğ•ğ•}Â´{(ğ•¨âŠ¸â‰¡âˆ§"*"â‰¡1â†‘âŠ£)â—¶âŸ¨â‹ˆâ‹„ğ•©â‹ˆËœ1â†“âŠ£âŸ©Â´}Â´Â¨âŸ¨
  "unsigned char"  â€¿"ustr"
  "char"           â€¿"str"
  "void"           â€¿"ptr"
  "rAudioBuffer"   â€¿"ptr"
  "rAudioProcessor"â€¿"ptr"
âŸ©
constTextâ†"const "
SwitchOrder â† {âŒ½âŒ¾((ğ•©âˆŠ'0'+â†•10)âŠ¸/)1âŠ¸âŒ½âŒ¾((ğ•©âˆŠ"[]")âŠ¸/)ğ•©}âŒ½

shortendStructNamesâ†[
  "v2"â€¿"Vector2"
  "v3"â€¿"Vector3"
  "v4"â€¿"Vector4"
]

typeReplacements â† â‰shortendStructNamesâˆ¾[
  # remove since they're not defined
  "ptr"â€¿"AudioCallback"
  "ptr"â€¿"LoadFileDataCallback"
  "ptr"â€¿"LoadFileTextCallback"
  "ptr"â€¿"SaveFileDataCallback"
  "ptr"â€¿"SaveFileTextCallback"
  "ptr"â€¿"TraceLogCallback"

  """f64"""â€¿"double"
  """i64"""â€¿"long"
  "f"      â€¿"float"
  "i"      â€¿"int"
  "ptr"    â€¿"..."
  "u"      â€¿"unsigned int"
  "u8"     â€¿"char"
  "u8"     â€¿"unsigned char"
  """u16"""â€¿"unsigned short"
  " "      â€¿"void"
]

mapArgTypes â† {
  [bqn,c] â† typeReplacements
  {
    constsâ†constTextâŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨ğ•©
    s â† Â¬constsâˆ¨Â¬âŠ‘Â¨'*'âŠ¸âˆŠÂ¨ğ•©
    cleanedâ†constTextâŠ¸âˆ¾â¼Â¨âŒ¾(constsâŠ¸/)ğ•©
    [kept,removed] â† 2â€¿âˆ˜â¥Šâ‰RemapâŒ¾âŒ½Ë˜> âˆ¨`âˆ˜âˆŠâŸœ"[*"âŠ¸(Â¬âŠ¸/âˆ¨`âŒ¾âŒ½âˆ˜â‰ âŸœ' 'âŠ¸/âŠ¸â‹ˆSwitchOrderâˆ˜/)Â¨cleaned
    replaced â† kept LowerNamesâˆ˜âŠ£âŸ(0âŠ¸â‰¡)Â¨(câŠkept)âŠbqnâˆ¾0
    removed {""ğ•Šğ•©:ğ•©;'"'â‰¡âŠ‘ğ•©?ğ•¨âŠ¸âˆ¾âŒ¾('"'âŠ¸âˆ¾â¼)ğ•©;'"'âˆ¾ğ•¨âˆ¾"""âˆ¾"âˆ¾ğ•©}Â¨ replaced
  }
}

MapStructTypes â† {
  [bqn,c] â† typeReplacements
  constsâ†constTextâŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨ğ•©
  s â† Â¬constsâˆ¨Â¬âŠ‘Â¨'*'âŠ¸âˆŠÂ¨ğ•©
  cleanedâ†constTextâŠ¸âˆ¾â¼Â¨âŒ¾(constsâŠ¸/)ğ•©
  [kept,removed] â† 2â€¿âˆ˜â¥Šâ‰RemapâŒ¾âŒ½Ë˜> âˆ¨`âˆ˜âˆŠâŸœ"[*"âŠ¸(Â¬âŠ¸/âˆ¨`âŒ¾âŒ½âˆ˜â‰ âŸœ' 'âŠ¸/âŠ¸â‹ˆSwitchOrderâˆ˜/)Â¨cleaned
  AddRemoved â† {""ğ•Šğ•©:ğ•©;'"'â‰¡âŠ‘ğ•©?ğ•¨âŠ¸âˆ¾âŒ¾('"'âŠ¸âˆ¾â¼)ğ•©;'"'âˆ¾ğ•¨âˆ¾"""âˆ¾"âˆ¾ğ•©}
  replaced â† kept LowerNamesâˆ˜âŠ£âŸ(0âŠ¸â‰¡)Â¨(câŠkept)âŠbqnâˆ¾0
  removed AddRemovedÂ¨ replaced
}

mapStructNames â† {
  [bqn,c]â†â‰shortendStructNames
  {ğ•©LowerNamesâˆ˜âŠ£âŸ(0âŠ¸â‰¡)Â¨(câŠğ•©)âŠbqnâˆ¾0}
}

mapFuncReturnType â† {
  [bqn,c] â† typeReplacements
  {
    cleanedâ†ğ•©â†“ËœÂ¨constTextâ‰ âŠ¸Ã—constTextâŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨ğ•©
    [kept,removed] â† 2â€¿âˆ˜â¥Šâ‰RemapâŒ¾âŒ½Ë˜> âˆ¨`âˆ˜âˆŠâŸœ"[*"âŠ¸(Â¬âŠ¸/Â¯1âŠ¸â†“âŸ(" "â‰¡Â¯1âŠ¸â†‘)âŠ¸â‹ˆSwitchOrderâˆ˜/)Â¨cleaned
    AddRemoved â† {""ğ•Šğ•©:ğ•©;'"'â‰¡âŠ‘ğ•©?ğ•¨âŠ¸âˆ¾âŒ¾('"'âŠ¸âˆ¾â¼)ğ•©;'"'âˆ¾ğ•¨âˆ¾"""âˆ¾"âˆ¾ğ•©}
    replaced â† kept LowerNamesâˆ˜âŠ£âŸ(0âŠ¸â‰¡)Â¨(câŠkept)âŠbqnâˆ¾0
    {'('âˆ¾ğ•©âˆ¾')'}âŸ(âˆ¨Â´"âˆ¾âŠ£"âŠ¸âˆŠ)Â¨"ptrâŠ£"âŠ¸âˆ¾âŸ(("ustr"â‰¡Â¯4âŠ¸â†‘)âˆ¨âˆ¨Â´âˆ˜=âŸœ'*'âˆ¨"str"â‰¡Â¯3âŠ¸â†‘)Â¨ removed AddRemovedÂ¨ replaced
  }
}

# turns header data from ParseHeader into ffi file characters
# ğ•¨ (pathToBinary) is optional, and can be the path to any file with the extentions:
#   ".dll" on windows, ".so" on linux, ".dylib" on macos, etc
ToFFI â† {ğ•¨ğ•Šdata: # pathToBinaryâ†ğ•¨
  definesâ€¿structsâ€¿aliasesâ€¿enumsâ€¿callbacksâ€¿functionsâ†{
    !ğ•©âŠ£ËâŠ¸â‰¡"defines"â€¿"structs"â€¿"aliases"â€¿"enums"â€¿"callbacks"â€¿"functions"
    âŠ¢ËÂ¨Â¨âŒ¾(0â€¿1â€¿3â€¿4â€¿5âŠ¸âŠ)âŠ¢Ëğ•©
  } json.Parse ToPrettyJson data
  top â† 1â†“âˆ¾nlâˆ¾Â¨âŸ¨
    "#### THIS TEXT HAS BEEN AUTOGENERATED ####"
    ""
    â€¢FChars "setupMacro.bqn"
    ""
    "r â‡ MakeImporter pathToBinaryâ‡"âˆ¾ğ•¨âŠ¢âŠ˜((âŠ¢âˆ¾âˆ¾)âŸœ'"')"âŠ‘â€¢args"
    ""
    "##################################"
    "# End of setup for easy ffi.     #"
    "# Begining of autogenerated ffi. #"
    "##################################"
    ""
  âŸ©
  topâˆ¾âˆ¾nlâˆ¾Â¨âˆ¨`âŒ¾âŒ½âˆ˜â‰ âŸœ' 'âŠ¸/Â¨âˆ¾âŸ¨
    { # defines
      exclTypes  â† "GUARD"â€¿"MACRO"â€¿"UNKNOWN"â€¿"FLOAT_MATH"â€¿"COLOR"
      Filter â† {ğ•Šnameâ€¿typeâ€¿valâ€¿desc:
        Â¬âˆ¨Â´âŸ¨"PI"â‰¡name, âˆ¨Â´typeâŠ¸â‰¡Â¨exclTypes, âŸ¨âŸ©â‰¡val âŸ©
      }
      filtered â† FilterË˜âŠ¸/>defines
      <Ë˜""â€¿""â€¿" â‡ "â€¿" # "âŸ¨LowerNamesÂ¨,âŸ¨âŸ©Â¨,â€¢ReprÂ¨,âŠ¢âŸ©_MetaParse filtered
    }
    â‹ˆ""
    { # enums
      [names,descriptions,values]â†â‰>enums
      tabled â† >Â¨âŠ¢ËÂ¨Â¨ values
      bodys â† (<Ë˜("  ")â€¿" â‡ "â€¿"  # "âŸ¨LowerNamesÂ¨,â€¢ReprÂ¨,âŠ¢âŸ©_MetaParseâŠ¢)Â¨tabled
      headers â† names LowerNamesâŠ¸âˆ¾Â¨<Ë˜" â‡ { # "âŠ¸âˆ¾Ë˜Box descriptions
      âˆ¾headers<âŠ¸âˆ¾Â¨âˆ¾âŸœâŸ¨"}"âŸ©Â¨bodys
    }
    â‹ˆ""
    { # structs
      [names,descriptions,fields]â†â‰>structs
      headers â† (MapStructNames names) âˆ¾âŸœ" â‡ âŸ¨ # "âŠ¸âˆ¾Â¨ descriptions
      bodys â† {âŸ¨"âŸ©"âŸ©âˆ¾Ëœ<Ë˜"  "â€¿" # "â€¿"  # "âŸ¨MapStructTypes,âŠ¢,âŠ¢âŸ©_MetaParse >ğ•©}Â¨âŠ¢ËÂ¨Â¨fields
      assembled â† headers <âŠ¸âˆ¾Â¨ bodys
      aliasLinesâ†Â»âŠ¸âˆ¨âˆ˜â‰ âŸœ' 'âŠ¸/Â¨<Ë˜""â€¿" â‡ "â€¿" # "âŸ¨LowerNamesÂ¨,MapArgTypes,âŠ¢âŸ©_MetaParse âŒ½âŒ¾(2âŠ¸â†‘)Ë˜>âŠ¢ËÂ¨aliases
      pâ†âŠ‘Â¨âŠ¢ËÂ¨aliases
      âˆ¾ âˆ¾âˆ¾âŸœ(â‹ˆâ‹ˆ)Â¨âŸœaliasLinesâŒ¾(Â¯1âŠ¸â†“)assembledâŠ”Ëœ+`Â»+Ëpâ‰¡âŒœnames
    }
    â‹ˆ""
    { # functions
      s â† {
        ((âŠ‘'*'âŠ¸âˆŠ)Â¨âˆ§constTextâŠ¸(âŠ£â‰¢â‰ âŠ¸â†‘)Â¨)1â€¿0âŠ¸âŠ‘Â¨Â¯1âŠ‘ğ•©
      }Â¨âˆ¾âŸœâŸ¨âŸ¨âŸ©âŸ©âŸ(3=â‰ )Â¨functions
      sLinesâ†âˆ¨Â´Â¨s

      s2 â† {
        "const void *"âŠ¸â‰¡Â¨1â€¿0âŠ¸âŠ‘Â¨Â¯1âŠ‘ğ•©
      }Â¨âˆ¾âŸœâŸ¨âŸ¨âŸ©âŸ©âŸ(3=â‰ )Â¨functions
      s2Linesâ†âˆ¨Â´Â¨s2
      !âˆ§Â´Â¬s2Linesâˆ§sLines # I don't want the lines to collide
      
      sAllLinesExtended â† (â†•âˆ˜â‰ âŠ¸+âŒ¾/â†‘Ëœ+Â´+â‰ )s2Linesâˆ¨sLines
      s1LinesExtendedâ€¿s2LinesExtended â† s2Lines{((+Â´+â‰ )ğ•©+ğ•¨)â†‘ğ•¨âŠ¸{((/ğ•¨)Â¬âˆ˜âˆŠËœğ•©)/ğ•©+â†•â‰ ğ•©}âŒ¾/ğ•¨+ğ•©}{ğ”½â‹ˆğ”½Ëœ}sLines
      MakeConstDistinct â† (sAllLinesExtendedÂ¬âŠ¸Ã—(1+s2Linesâˆ¨sLines)/s+2Ã—s2){'âŸ©'âˆ¾Ëœ1â†“âˆ¾'â‹„'âˆ¾Â¨(âŠ‘"ptr"â€¿"ustr"â€¿"str"âŠ<)â—¶âŸ¨"""&u8"""â‹„"""&u8"""â‹„"""&u8:c8"""â‹„"""&"âŠ¸âˆ¾"""*"âŠ¸âˆ¾â¼âŸ©Â¨âŒ¾((1=ğ•¨)âŠ¸/)"""*i8"""Â¨âŒ¾((2=ğ•¨)âŠ¸/)ğ•©}Â¨âŠ¢

      <Ë˜""â€¿" â‡ "â€¿""""â€¿" _RâŸ¨"â€¿"#"â€¿" # "âŸ¨
        âˆ¾âŸœ"Raw"Â¨âŒ¾((Â»s2LinesExtended)âŠ¸/)Â·âˆ¾âŸœ"Ref"Â¨âŒ¾((Â»s1LinesExtended)âŠ¸/)LowerNamesÂ¨ â‹„ MapFuncReturnType â‹„ âˆ¾âŸœ'"'Â¨ â‹„ MakeConstDistinct MapArgTypesÂ¨ â‹„ (âˆ¾' 'âŠ¸âˆ¾Â¨)Â¨ â‹„ âŠ¢
      âŸ©_MetaParseâŸ(âŸ¨âŸ©âŠ¸â‰¢){
        0â€¿2â€¿0â€¿3â€¿4â€¿1âŠ(3â†‘ğ•©)âˆ¾â‰{<Ë˜â‰âˆ˜â€¿2â¥ŠâŠ¢ËË˜>âŠ‘ğ•©}Ë˜âŠ¢Ëğ•©
      }âŒ¾â‰âŸ(âŸ¨âŸ©âŠ¸â‰¢)(1+s2Linesâˆ¨sLines)/>âˆ¾âŸœâŸ¨âŸ¨âŸ©âŸ©âŸ(3=â‰ )Â¨functions
    }
  âŸ©
}


# Type of parsed define
âŸ¨
  unknown
  macro
  guard
  int
  int_math
  long
  long_math
  float
  float_math
  double
  double_math
  char
  string
  color
âŸ© â† â†•14

# Get data type and name from a string containing both
# NOTE: Useful to parse function parameters and struct fields
GetDataTypeAndName â† (âˆ¨`âŒ¾âŒ½âˆŠâŸœ"* ">âˆ¨`âˆ˜=âŸœ',')âŠ¸(/â‹ˆÂ¬âŠ¸/) #â€¿typeâ€¿name: # const char *typeName, int typeNameLen, char *type, char *name)

# Get comment from a line, do nothing if no comment in line
GetDescription â† âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/2â†“âˆ¨`âˆ˜âˆ§âŸœÂ«âˆ˜=âŸœ'/'âŠ¸/ # str â†’ description (str)

defMacro â† "#define"

# Reads list of characters ğ•© (headerChars) that represent a header file.
# Optional ğ•¨ (definePrefix), needed if you want to parse functions. It's the function prefix of choice.
# Outputs header data.
# Example1: "RLAPI" ParseHeader â€¢FChars "file-name.h"
# Example2: ParseHeader â€¢FChars "other-file.h"
ParseHeader â† {ğ•¨ğ•ŠheaderChars:
  # Example:
  # ğ•¨ â† "RLAPI" # Functions define (i.e. RLAPI for raylib.h)
  definePrefix â† ğ•¨âŠ£"NO_FUNCTIONS"

  headerLines â† nl((âŠ¢-Ëœ+`Ã—Â¬)âˆ˜=âŠ”âŠ¢)headerChars

  lines â† ' 'âŸ((9+@)âŠ¸â‰¡)Â¨Â¨ headerLines

  defines â† (âˆŠâŠ‘Â¨)âŠ¸/ Â¯1âŠ‘Â¨{lastDefinesğ•ŠlinePtr:
    type â† 0
    ishex â† 0
    operand â† âŸ¨âŸ©

    LS â† âˆ¨`âˆ˜â‰ âŸœ' ' # leading spacing
    nameAndArgs â† LSâŠ¸/ defMacroâˆ¾â¼LSâŠ¸/âŠ‘linePtr # Skip defMacro, then spaces again

    # Extract name    
    nameLen â† â‰¤Â´âˆ˜âŠâŸœ" ("â—¶âŸ¨
      1+âŠâŸœ')'
      âŠâŸœ' '
    âŸ© nameAndArgs

    nameâ€¿args â† nameLen(â†‘â‹ˆLSâŠ¸/âˆ˜â†“)nameAndArgs

    # Determine type
    {ğ•Š:typeâ†©macro}âŸâŠ¢')'=Â¯1âŠ‘name
    {ğ•Š:typeâ†©guard}âŸâŠ¢(0=â‰ args)âˆ¨"/"â‰¡1â†‘args

    {
      """"â‰¡1â†‘args?
        typeâ†©string
    ;
      "'"â‰¡1â†‘args?
        typeâ†©char
    ;
      "CLITERAL(Color)"â‰¡15â†‘args?
        typeâ†©color
    ;
      âŠ‘"0123456789"âˆŠËœ1â†‘args?
        chars â† âˆ§`âˆ˜â‰ âŸœ' 'âŠ¸/args
        isFloat â† âˆ¨Â´'.'=chars
        isHexTemp â† âˆ¨Â´'x'=chars

        {ğ•¤
          isFloat?
            type â†© (ğ•©='f')âŠ‘doubleâ€¿float
        ;
            type â†© (ğ•©='L')âŠ‘intâ€¿long
            isHex â†© isHexTemp
        }Â¨(Â¬âˆ˜Â«âˆŠâŸœ"0123456789xL.+-ABCDEFabcdef")âŠ¸/chars
    ;@
    }

    # Extracting value
    fullValue â† âˆ¨`âŒ¾âŒ½âˆ˜â‰ âŸœ' 'âŠ¸/args/ËœÂ¬âˆ¨`(â‰ args)â†‘"//"â·args
    value â† fullValueâ†“Ëœ-âŠ‘typeâˆŠlongâ€¿float # Remove number postfix

    # Extracting description
    description â† GetDescription args

    # Parse defines of type UNKNOWN to find calculated numbers
    isMath â† 1
    {ğ•¤
      conds â† (âˆŠâŸœ"0123456789.">âˆŠâŸœ"()+-*/ ")value
      numbers â† conds (Â¬-ËœâŠ¢Ã—Â·+`Â»âŠ¸>)âŠ¸âŠ” value 
      operands â† (Â¬conds) (Â¬-ËœâŠ¢Ã—Â·+`Â»âŠ¸>)âŠ¸âŠ” value 
      areNumbers â† âˆ¨Â´Â¨âˆŠâŸœ"0123456789xL.+-abcdefABCDEF"Â¨numbers
      isMathâ†©âˆ§Â´areNumbers
      
      # Read number operand
      # Found a valid number -> update largestType
      type âŒˆâ†© âŒˆÂ´{
        isFloatâ†âˆ¨Â´('.'=ğ•©)âˆ§âˆ§`âˆŠâŸœ"0123456789abcdefABCDEFxL.+-"ğ•©
        [
          long_mathâ€¿int_math
          float_mathâ€¿double_math
        ]âŠ‘ËœisFloat(âŠ£â‹ˆâŠ‘)"Lf"=âŠ‘ğ•©
      }Â¨areNumbers/numbers
      {
        # Search previous defines for operand
        # Found operand and it's a number -> update type
        foundOperandsâ†(âˆ§`â‰¥âŸœintâˆ§â‰¤âŸœdouble_math)âŠ¸/((ğ•©â‰¡âŠ‘)Â¨/1âŠ¸âŠ‘Â¨)2â†‘Â¨lastDefines

        typeâŒˆâ†©âŒˆÂ´foundOperands
        isMathâˆ§â†©0<â‰ foundOperands
      }Â¨operands
      {ğ•¤
        # Define is a calculated number -> update type
        mathTypes â† int_mathâ€¿long_mathâ€¿float_mathâ€¿double_mathâ€¿type
        typeâ†©mathTypesâŠ‘ËœâŠ‘intâ€¿longâ€¿floatâ€¿doubleâŠtype
      }âŸâŠ¢isMath
    }âŸâŠ¢type=unknown
    lastNamesâ†âŠ‘Â¨lastDefines
    ğ•¨ âˆ¾âŸœ< nameâ€¿typeâ€¿valueâ€¿descriptionâ€¿ishexâ€¿operand
  }`Â´(<âŸ¨âŸ©)â‹ˆâ†“âŸœlinesÂ¨/defMacroâŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/Â¨lines

  # Structs info data
  structs â† {ğ•¤
    linesPtr â† âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/Â¨ğ•©â†“lines

    # Parse struct description
    desc â† GetDescription (ğ•©-1)âŠ‘lines

    # Get struct name: typedef struct name {
    nameâ†' 'âŠ¸â‰ âŠ¸/âˆ§`âˆ˜â‰ âŸœ'{'âŠ¸/"typedef struct "âˆ¾â¼âŠ‘linesPtr

    # Get struct fields and count them -> fields finish with ;
    fields â† âˆ¾Â´{
      fieldTypeâ€¿fieldNamesUnparsed â† GetDataTypeAndName âŠâŸœ';'âŠ¸â†‘ğ•©
      fieldType âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/âŒ¾âŒ½â†©
      fieldNames â† ','((âŠ¢-Ëœ+`Ã—Â¬)âˆ˜=âŠ”âŠ¢)fieldNamesUnparsed
      fieldNames âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/Â¨â†©
      fieldDesc  â†  GetDescription ğ•©

      # Move type len info from name to type
      fieldTypes â† {fieldTypeâˆ¾âˆ¨`âˆ˜=âŸœ'['âŠ¸/ğ•©}Â¨fieldnames
      fieldnames âˆ§`âˆ˜â‰ âŸœ'['âŠ¸/Â¨â†©

      (<fieldDesc)âŠ¸âˆ¾Â¨fieldTypesâ‹ˆÂ¨fieldNames
    }Â¨(âˆ§Â´"struct"â€¿"/"â€¿" "â‰¢Â¨6â€¿1â€¿1â†‘Â¨<)Â¨âŠ¸/âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/Â¨(âˆ§`'}'â‰ Â·âˆ¾Â´1âŠ¸â†‘Â¨)âŠ¸/1â†“linesPtr

    nameâ€¿descâ€¿fields

    # Read struct lines
    # Find structs
    # starting with "typedef struct ... {" or "typedef struct ... ; \n struct ... {"
    # ending with "} ... ;"
    # i.e. excluding "typedef struct rAudioBuffer rAudioBuffer;" -> Typedef and forward declaration only
  }Â¨/{
    [m1,m2]â†"typedef struct"â€¿"struct"(âŠ£â‰¡â‰ âŠ¸â†‘)âŒœ âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/Â¨ğ•©
    m1âˆ§m2Â«âŠ¸âˆ¨<Â´âˆ˜âŠâŸœ"{;"Â¨ğ•©
  } lines

  # Alias info data
  aliases â† {ğ•¤
    linePtr â†ğ•©âŠ‘lines
    desc â† (linesâŠ‘Ëœğ•©-1)âŠ£âŸ(""âŠ¸â‰¡)â—‹GetDescription linePtr
    typeâ€¿name â† ' '((Â¬-ËœâŠ¢Ã—Â·+`Â»âŠ¸>)âˆ˜â‰ âŠ”âŠ¢)"typedef "âˆ¾â¼âŠâŸœ'/'âŠ¸â†‘linePtr  
    name âˆ¾âŸœ";"â¼â†©
    typeâ€¿nameâ€¿desc
  }Â¨/(âˆ¨Â´âˆ˜=âŸœ';'âˆ§"typedef"âŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)âˆ§2=(+Â´' 'âŠ¸=>âˆ¨`âˆ˜=âŸœ';'))Â¨lines # Find aliases (lines with "typedef ... ...;")

  enums â† {
    # Parse enum description
    # NOTE: This is not necessarily from the line immediately before,
    # some of the enums have extra lines between the "description"
    # and the typedef enum
    desc â† GetDescription âŸ¨âŸ©âŠ¸â‰¡â—¶âŠ‘â€¿""(âˆ§`("// "â‰¡3âŠ¸â†‘)Â¨)âŠ¸/âŒ¾âŒ½ğ•©â†‘lines

    # Parse enum value line, possible options:
    #ENUM_VALUE_NAME,
    #ENUM_VALUE_NAME
    #ENUM_VALUE_NAME     = 99
    #ENUM_VALUE_NAME     = 99,
    #ENUM_VALUE_NAME     = 0x00000040,   # Value description
    values â† {ğ•¤
      valueInteger â† âŸ¨âŸ©

      # We start reading the value name
      valueNameâ†(âˆ§`Â·âˆ§Ë", ="â‰ âŒœâŠ¢)âŠ¸/ğ•©

      # After the name we can have:
      #  '='  -> value is provided
      #  ','  -> value is equal to previous + 1, there could be a description if not '\0'
      #  ' '  -> value is equal to previous + 1, there could be a description if not '\0'
      #  '\0' -> value is equal to previous + 1

      # Let's start checking if the line is not finished
      # Two options:
      #  '='  -> value is provided
      #  ' '  -> value is equal to previous + 1, there could be a description if not '\0'
      
      valuesUnparsedâ†Â¬âˆ˜âˆŠâŸœ", "âŠ¸/valueNameâˆ¾â¼âŠâŸœ'/'âŠ¸â†‘ğ•©

      value â† {"="â‰¡1â†‘ğ•©?
        {"0x"â‰¡2â†‘ğ•©?
          16âŠ¸Ã—âŠ¸+ËœÂ´âŒ½(âˆ¾"0A"+âŸœâ†•Â¨10â€¿6)âŠ2â†“ğ•©
        ;
          â€¢ParseFloatğ•©
        }'='âŠ¸âˆ¾â¼ğ•©
        ;@
      } valuesUnparsed

      # Parse value description
      valueDesc â† GetDescription ğ•©

      valueNameâ€¿valueâ€¿valueDesc
    }Â¨((â‰¥âŸœ'A'âˆ§'Z'âŠ¸â‰¥)âˆ˜âŠ‘Â¨1â†‘Â¨âŠ¢)âŠ¸/ âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/Â¨(âˆ§`'}'â‰ Â·âŠ‘Â¨1â†‘Â¨âŠ¢)âŠ¸/linesâ†“Ëœ1+ğ•©
    
    values {ğ•©=@?ğ•¨+1;ğ•©}`âŒ¾(1âŠ¸âŠ‘Â¨)â†©
    values â€¢ReprÂ¨âŒ¾(1âŠ¸âŠ‘Â¨)â†©

    # Get enum name from typedef
    nameâ†"} "âˆ¾â¼âŠâŸœ';'âŠ¸â†‘ (âŠ‘âˆ˜âŠâŸœ'}'Â·âˆ¾Â´1â†‘Â¨âŠ¢)âŠ¸âŠ‘linesâ†“Ëœ1+ğ•©

    nameâ€¿descâ€¿values

    # Read enum lines
    # ignore inline enums
  }Â¨/("typedef enum {"âŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)âˆ§âˆ¨Â´âˆ˜â‰ âŸœ';')Â¨lines

  callbacks â† {
    RLS â† âˆ¨`âˆ˜â‰ âŸœ' 'âŠ¸/
    
    # Return type
    afterDef â† RLS "typedef "âˆ¾â¼ğ•©
    retType â† RLSâŒ¾âŒ½ âŠâŸœ'('âŠ¸â†‘afterDef
    afterStar â† RLS "(*"âˆ¾â¼ RLS retTypeâˆ¾â¼RLS afterDef
    name â† RLSâŒ¾âŒ½ âŠâŸœ')'âŠ¸â†‘ afterStar
    afterName â† RLS")("âˆ¾â¼RLS nameâˆ¾â¼afterStar

    # âŸ¨paramTypeâ€¿paramName, ...âŸ©
    [paramTypes,paramNames] â† â‰>GetDataTypeAndNameÂ¨ ','((âŠ¢-Ëœ+`Ã—Â¬)âˆ˜=âŠ”âŠ¢) âŠâŸœ')'âŠ¸â†‘afterName

    # Move array sizes from name to type
    paramTypesâˆ¾Â¨â†©âŠâŸœ'['âŠ¸â†“Â¨paramNames
    paramNames âŠâŸœ'['âŠ¸â†‘Â¨â†©
    paramTypes (âˆ¨`âˆ§âˆ¨`âŒ¾âŒ½)âˆ˜â‰ âŸœ' 'âŠ¸/Â¨â†©

    # Description
    desc â† GetDescription ğ•©

    paramCountâ†â‰ paramNames
    nameâ€¿descâ€¿retTypeâ€¿paramTypesâ€¿paramNames
  }Â¨{
    # Read callback lines
    # Find callbacks (lines with "typedef ... (* ... )( ... );")
    m1â†"typedef"âŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨ğ•©
    m1âˆ§{((âˆ¨Â´");"âŠ¸â‰¡Ë˜)âˆ§(âˆ¨Â´")("âŠ¸â‰¡Ë˜)âˆ§(âˆ¨Â´"(*"âŠ¸â‰¡Ë˜))2â†•" "âŸ(""âŠ¸â‰¡)ğ•©}Â¨ğ•©
  }âŠ¸/lines

  functions â† {
    funcSignature â† ğ•©âˆ¾â¼ËœdefinePrefixâˆ¾' '

    retTypeâ€¿name â† GetDataTypeAndName âŠâŸœ'('âŠ¸â†‘funcSignature
    retType (âˆ¨`âˆ§âˆ¨`âŒ¾âŒ½)âˆ˜â‰ âŸœ' 'âŠ¸/â†©

    [paramTypesâ‹„paramNames]â†âŸ¨âŸ©âŠ¸â‰¢â—¶âŸ¨â†•2â€¿0â‹„â‰>âŸ©("void"â‰¢Â¯4âŠ¸â†‘)â—¶âŸ¨
      âŸ¨âŸ© â‹„ {GetDataTypeAndNameÂ¨(âˆ¨`âˆ§âˆ¨âŸœÂ«)âˆ˜â‰ âŸœ' 'âŠ¸/Â¨','((âŠ¢-Ëœ+`Ã—Â¬)âˆ˜=âŠ”âŠ¢)ğ•©}
    âŸ© âŠâŸœ')'âŠ¸â†‘(1+âŠâŸœ'(')âŠ¸â†“funcSignature

    # Move array sizes from name to type
    paramTypesâˆ¾Â¨â†©âŠâŸœ'['âŠ¸â†“Â¨paramNames
    paramTypes (âˆ¨`âˆ§âˆ¨`âŒ¾âŒ½)âˆ˜â‰ âŸœ' 'âŠ¸/Â¨â†©

    paramNames âŠâŸœ'['âŠ¸â†‘Â¨â†©

    paramTypesâ€¿paramNames {<Ë˜"..."âŠ¸â‰¡â—¶âŸ¨â‹ˆâ‹„"..."â€¿"args"âŸ©Â´Ë˜âŒ¾â‰>ğ•©}â†©

    desc â† GetDescription ğ•©

    nameâ€¿descâ€¿retTypeâ€¿paramNamesâ€¿paramTypes

    # Read function lines
    # Read function line (starting with `define`)
  }Â¨definePrefixâŠ¸(âŠ£â‰¡â‰ âŠ¸â†‘)Â¨âŠ¸/lines

  definesâ€¿structsâ€¿aliasesâ€¿enumsâ€¿callbacksâ€¿functions
}

# Reads header data from ParseHeader and makes a pretty json file
ToPrettyJson â† {ğ•Šdefinesâ€¿structsâ€¿aliasesâ€¿enumsâ€¿callbacksâ€¿functions:
  EscapeBackslashesâ†âˆ¾'\'âŠ¸=â—¶â‹ˆâ€¿"\\"Â¨

  # Export parsed data in json
  1â†“âˆ¾nlâˆ¾Â¨âˆ¾âŸ¨
    â‹ˆ"{"

    # Print defines info
    â‹ˆ"  ""defines"": ["
    Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âˆ¾{ğ•Šnameâ€¿typeâ€¿valueâ€¿descriptionâ€¿ishexâ€¿operand:âˆ¾âŸ¨
      â‹ˆ"    {"
      â‹ˆ"      ""name"": """âˆ¾nameâˆ¾""","
      â‹ˆ"      ""type"": """âˆ¾(typeâŠ‘âŸ¨
        "UNKNOWN"
        "MACRO"
        "GUARD"
        "INT"
        "INT_MATH"
        "LONG"
        "LONG_MATH"
        "FLOAT"
        "FLOAT_MATH"
        "DOUBLE"
        "DOUBLE_MATH"
        "CHAR"
        "STRING"
        "COLOR"
      âŸ©)âˆ¾""","
      â‹ˆ{isHex? # INT or LONG
        "      ""value"": "âˆ¾(16âŠ¸Ã—âŠ¸+ËœÂ´âŒ½valueâŠËœâˆ¾"0A"+âŸœâ†•Â¨10â€¿6)âˆ¾","
      ;âˆ¨Â´type = intâ€¿longâ€¿floatâ€¿doubleâ€¿string?
        "      ""value"": "âˆ¾valueâˆ¾','
      ;
        "      ""value"": """âˆ¾valueâˆ¾""","
      }
      â‹ˆ"      ""description"": """âˆ¾descriptionâˆ¾""""
      â‹ˆ"    },"
    âŸ©}Â¨defines
    â‹ˆ"  ],"
    # Print structs info
    â‹ˆ"  ""structs"": ["
    Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âˆ¾{ğ•Šnameâ€¿descâ€¿fields:âˆ¾âŸ¨
      â‹ˆ"    {"
      â‹ˆ"      ""name"": """âˆ¾nameâˆ¾""","
      â‹ˆ"      ""description"": """âˆ¾(EscapeBackslashes desc)âˆ¾""","
      â‹ˆ"      ""fields"": ["
      Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âŸ¨âŸ©âˆ¾Â´{ğ•ŠfieldDescâ€¿fieldTypeâ€¿fieldName:âŸ¨
        "        {"
        "          ""type"": """âˆ¾fieldTypeâˆ¾""","
        "          ""name"": """âˆ¾fieldNameâˆ¾""","
        "          ""description"": """âˆ¾(EscapeBackslashes fieldDesc)âˆ¾""""
        "        },"
      âŸ©}Â¨fields
      â‹ˆ"      ]"
      â‹ˆ"    },"
    âŸ©}Â¨structs
    â‹ˆ"  ],"

    # Print aliases info
    â‹ˆ"  ""aliases"": ["
    Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âˆ¾{ğ•Štypeâ€¿nameâ€¿desc:âŸ¨
      "    {"
      "      ""type"": """âˆ¾typeâˆ¾""","
      "      ""name"": """âˆ¾nameâˆ¾""","
      "      ""description"": """âˆ¾descâˆ¾'"'
      "    },"
    âŸ©}Â¨aliases
    â‹ˆ"  ],"

    # Print enums info
    â‹ˆ"  ""enums"": ["
    Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âˆ¾{ğ•Šnameâ€¿descâ€¿values:
      âˆ¾âŸ¨
        â‹ˆ"    {"
        â‹ˆ"      ""name"": """âˆ¾nameâˆ¾""","
        â‹ˆ"      ""description"": """âˆ¾(EscapeBackslashes desc)âˆ¾""","
        â‹ˆ"      ""values"": ["
        Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âˆ¾{ğ•ŠvalueNameâ€¿valueâ€¿valueDesc:
          âŸ¨
            "        {"
            "          ""name"": """âˆ¾valueNameâˆ¾""","
            "          ""value"": "âˆ¾valueâˆ¾","
            "          ""description"": """âˆ¾(EscapeBackslashes valueDesc)âˆ¾'"'
            "        },"
          âŸ©
        }Â¨values
        â‹ˆ"      ]"
        â‹ˆ"    },"
      âŸ©
    }Â¨enums
    â‹ˆ"  ],"

    # Print callbacks info
    â‹ˆ"  ""callbacks"": ["
    Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âˆ¾{ğ•Šnameâ€¿descâ€¿retTypeâ€¿paramTypesâ€¿paramNames:âˆ¾âŸ¨
      â‹ˆ"    {"
      â‹ˆ"      ""name"": """âˆ¾nameâˆ¾""","
      â‹ˆ"      ""description"": """âˆ¾(EscapeBackslashes desc)âˆ¾""",",
      â‹ˆ"      ""returnType"": """âˆ¾retTypeâˆ¾""""âˆ¾","/ËœâŸ¨âŸ©â‰¢paramTypes
      âŸ¨âŸ©âŸ(âŸ¨âŸ©â‰¡paramTypes)âˆ¾âŸ¨
        â‹ˆ"      ""params"": ["
        Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âˆ¾paramTypes{
          âŸ¨
            "        {"
            "          ""type"": """âˆ¾ğ•¨âˆ¾"""," 
            "          ""name"": """âˆ¾ğ•©âˆ¾""""  
            "        },"
          âŸ©
        }Â¨paramNames
        â‹ˆ"      ]"
      âŸ©
      â‹ˆ"    },"
    âŸ©}Â¨callbacks
    â‹ˆ"  ],"

    # Print functions info
    â‹ˆ"  ""functions"": ["
    Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âˆ¾{ğ•Šnameâ€¿descâ€¿retTypeâ€¿paramNamesâ€¿paramTypes: 
      âˆ¾âŸ¨
        â‹ˆ"    {"
        â‹ˆ"      ""name"": """âˆ¾nameâˆ¾""","
        â‹ˆ"      ""description"": """âˆ¾(EscapeBackslashes desc)âˆ¾""","
        â‹ˆ"      ""returnType"": """âˆ¾retTypeâˆ¾""""âˆ¾","/ËœâŸ¨âŸ©â‰¢paramTypes
        âŸ¨âŸ©âŸ(âŸ¨âŸ©â‰¡paramTypes) âˆ¾âŸ¨
          â‹ˆ"      ""params"": ["
          Â¯1âŠ¸â†“âŒ¾(Â¯1âŠ¸âŠ‘)âŸ(âŸ¨âŸ©âŠ¸â‰¢)âˆ¾paramTypes{
            âŸ¨
              "        {"
              "          ""type"": """âˆ¾ğ•¨âˆ¾""","
              "          ""name"": """âˆ¾ğ•©âˆ¾'"'
              "        },"
            âŸ©
          }Â¨paramNames
          â‹ˆ"      ]"
        âŸ©
        â‹ˆ"    },"
      âŸ©
    }Â¨functions

    â‹ˆ"  ]"
    â‹ˆ"}"
  âŸ©
}

HeaderToFFI â† ToFFI ParseHeader