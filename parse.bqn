⟨
  HeaderToFFI  # Read string 𝕩 and optional function prefix 𝕨, outputs metaprogrammed file as string
  ToFFI        # turns header data from ParseHeader into ffi file characters
  ParseHeader  # Read string 𝕩 and optional function prefix 𝕨, outputs header data
  ToPrettyJson # Read header data from ParseHeader and makes a pretty json file
⟩⇐

json ← •Import "json.bqn"

# util functions
nl ← @+10 # newline
Box ← ⟨⟩⊸≡◶⟨>⋄↕0‿0⟩⊢»¨⟜<' '⥊˜0⌈´≠¨
LowerNames ← +⟜(32×1="A["⊸⍋)⌾(1↑⎉1⊢)⍟(⟨⟩⊸≢)
_MetaParse ← {∾˘´[𝕗,𝕨]{F‿w𝕊𝕩:<w⊸∾˘Box F𝕩}˘○⍉⍉∘[⟨⟩⋄⟨⟩⋄⟨⟩]⍟(⟨⟩⊸≡)𝕩}

remap ← {𝕎𝕏}´{(𝕨⊸≡∧"*"≡1↑⊣)◶⟨⋈⋄𝕩⋈˜1↓⊣⟩´}´¨⟨
  "unsigned char"  ‿"ustr"
  "char"           ‿"str"
  "void"           ‿"ptr"
  "rAudioBuffer"   ‿"ptr"
  "rAudioProcessor"‿"ptr"
⟩
constText←"const "
SwitchOrder ← {⌽⌾((𝕩∊'0'+↕10)⊸/)1⊸⌽⌾((𝕩∊"[]")⊸/)𝕩}⌽

shortendStructNames←[
  "v2"‿"Vector2"
  "v3"‿"Vector3"
  "v4"‿"Vector4"
]

typeReplacements ← ⍉shortendStructNames∾[
  # remove since they're not defined
  "ptr"‿"AudioCallback"
  "ptr"‿"LoadFileDataCallback"
  "ptr"‿"LoadFileTextCallback"
  "ptr"‿"SaveFileDataCallback"
  "ptr"‿"SaveFileTextCallback"
  "ptr"‿"TraceLogCallback"

  """f64"""‿"double"
  """i64"""‿"long"
  "f"      ‿"float"
  "i"      ‿"int"
  "ptr"    ‿"..."
  "u"      ‿"unsigned int"
  "u8"     ‿"char"
  "u8"     ‿"unsigned char"
  """u16"""‿"unsigned short"
  " "      ‿"void"
]

mapArgTypes ← {
  [bqn,c] ← typeReplacements
  {
    consts←constText⊸(⊣≡≠⊸↑)¨𝕩
    s ← ¬consts∨¬⊑¨'*'⊸∊¨𝕩
    cleaned←constText⊸∾⁼¨⌾(consts⊸/)𝕩
    [kept,removed] ← 2‿∘⥊⍉Remap⌾⌽˘> ∨`∘∊⟜"[*"⊸(¬⊸/∨`⌾⌽∘≠⟜' '⊸/⊸⋈SwitchOrder∘/)¨cleaned
    replaced ← kept LowerNames∘⊣⍟(0⊸≡)¨(c⊐kept)⊏bqn∾0
    removed {""𝕊𝕩:𝕩;'"'≡⊑𝕩?𝕨⊸∾⌾('"'⊸∾⁼)𝕩;'"'∾𝕨∾"""∾"∾𝕩}¨ replaced
  }
}

MapStructTypes ← {
  [bqn,c] ← typeReplacements
  consts←constText⊸(⊣≡≠⊸↑)¨𝕩
  s ← ¬consts∨¬⊑¨'*'⊸∊¨𝕩
  cleaned←constText⊸∾⁼¨⌾(consts⊸/)𝕩
  [kept,removed] ← 2‿∘⥊⍉Remap⌾⌽˘> ∨`∘∊⟜"[*"⊸(¬⊸/∨`⌾⌽∘≠⟜' '⊸/⊸⋈SwitchOrder∘/)¨cleaned
  AddRemoved ← {""𝕊𝕩:𝕩;'"'≡⊑𝕩?𝕨⊸∾⌾('"'⊸∾⁼)𝕩;'"'∾𝕨∾"""∾"∾𝕩}
  replaced ← kept LowerNames∘⊣⍟(0⊸≡)¨(c⊐kept)⊏bqn∾0
  removed AddRemoved¨ replaced
}

mapStructNames ← {
  [bqn,c]←⍉shortendStructNames
  {𝕩LowerNames∘⊣⍟(0⊸≡)¨(c⊐𝕩)⊏bqn∾0}
}

mapFuncReturnType ← {
  [bqn,c] ← typeReplacements
  {
    cleaned←𝕩↓˜¨constText≠⊸×constText⊸(⊣≡≠⊸↑)¨𝕩
    [kept,removed] ← 2‿∘⥊⍉Remap⌾⌽˘> ∨`∘∊⟜"[*"⊸(¬⊸/¯1⊸↓⍟(" "≡¯1⊸↑)⊸⋈SwitchOrder∘/)¨cleaned
    AddRemoved ← {""𝕊𝕩:𝕩;'"'≡⊑𝕩?𝕨⊸∾⌾('"'⊸∾⁼)𝕩;'"'∾𝕨∾"""∾"∾𝕩}
    replaced ← kept LowerNames∘⊣⍟(0⊸≡)¨(c⊐kept)⊏bqn∾0
    {'('∾𝕩∾')'}⍟(∨´"∾⊣"⊸∊)¨"ptr⊣"⊸∾⍟(("ustr"≡¯4⊸↑)∨∨´∘=⟜'*'∨"str"≡¯3⊸↑)¨ removed AddRemoved¨ replaced
  }
}

# turns header data from ParseHeader into ffi file characters
# 𝕨 (pathToBinary) is optional, and can be the path to any file with the extentions:
#   ".dll" on windows, ".so" on linux, ".dylib" on macos, etc
ToFFI ← {𝕨𝕊data: # pathToBinary←𝕨
  defines‿structs‿aliases‿enums‿callbacks‿functions←{
    !𝕩⊣˝⊸≡"defines"‿"structs"‿"aliases"‿"enums"‿"callbacks"‿"functions"
    ⊢˝¨¨⌾(0‿1‿3‿4‿5⊸⊏)⊢˝𝕩
  } json.Parse ToPrettyJson data
  top ← 1↓∾nl∾¨⟨
    "#### THIS TEXT HAS BEEN AUTOGENERATED ####"
    ""
    •FChars "setupMacro.bqn"
    ""
    "r ⇐ MakeImporter pathToBinary⇐"∾𝕨⊢⊘((⊢∾∾)⟜'"')"⊑•args"
    ""
    "##################################"
    "# End of setup for easy ffi.     #"
    "# Begining of autogenerated ffi. #"
    "##################################"
    ""
  ⟩
  top∾∾nl∾¨∨`⌾⌽∘≠⟜' '⊸/¨∾⟨
    { # defines
      exclTypes  ← "GUARD"‿"MACRO"‿"UNKNOWN"‿"FLOAT_MATH"‿"COLOR"
      Filter ← {𝕊name‿type‿val‿desc:
        ¬∨´⟨"PI"≡name, ∨´type⊸≡¨exclTypes, ⟨⟩≡val ⟩
      }
      filtered ← Filter˘⊸/>defines
      <˘""‿""‿" ⇐ "‿" # "⟨LowerNames¨,⟨⟩¨,•Repr¨,⊢⟩_MetaParse filtered
    }
    ⋈""
    { # enums
      [names,descriptions,values]←⍉>enums
      tabled ← >¨⊢˝¨¨ values
      bodys ← (<˘("  ")‿" ⇐ "‿"  # "⟨LowerNames¨,•Repr¨,⊢⟩_MetaParse⊢)¨tabled
      headers ← names LowerNames⊸∾¨<˘" ⇐ { # "⊸∾˘Box descriptions
      ∾headers<⊸∾¨∾⟜⟨"}"⟩¨bodys
    }
    ⋈""
    { # structs
      [names,descriptions,fields]←⍉>structs
      headers ← (MapStructNames names) ∾⟜" ⇐ ⟨ # "⊸∾¨ descriptions
      bodys ← {⟨"⟩"⟩∾˜<˘"  "‿" # "‿"  # "⟨MapStructTypes,⊢,⊢⟩_MetaParse >𝕩}¨⊢˝¨¨fields
      assembled ← headers <⊸∾¨ bodys
      aliasLines←»⊸∨∘≠⟜' '⊸/¨<˘""‿" ⇐ "‿" # "⟨LowerNames¨,MapArgTypes,⊢⟩_MetaParse ⌽⌾(2⊸↑)˘>⊢˝¨aliases
      p←⊑¨⊢˝¨aliases
      ∾ ∾∾⟜(⋈⋈)¨⟜aliasLines⌾(¯1⊸↓)assembled⊔˜+`»+˝p≡⌜names
    }
    ⋈""
    { # functions
      s ← {
        ((⊑'*'⊸∊)¨∧constText⊸(⊣≢≠⊸↑)¨)1‿0⊸⊑¨¯1⊑𝕩
      }¨∾⟜⟨⟨⟩⟩⍟(3=≠)¨functions
      sLines←∨´¨s

      s2 ← {
        "const void *"⊸≡¨1‿0⊸⊑¨¯1⊑𝕩
      }¨∾⟜⟨⟨⟩⟩⍟(3=≠)¨functions
      s2Lines←∨´¨s2
      !∧´¬s2Lines∧sLines # I don't want the lines to collide
      
      sAllLinesExtended ← (↕∘≠⊸+⌾/↑˜+´+≠)s2Lines∨sLines
      s1LinesExtended‿s2LinesExtended ← s2Lines{((+´+≠)𝕩+𝕨)↑𝕨⊸{((/𝕨)¬∘∊˜𝕩)/𝕩+↕≠𝕩}⌾/𝕨+𝕩}{𝔽⋈𝔽˜}sLines
      MakeConstDistinct ← (sAllLinesExtended¬⊸×(1+s2Lines∨sLines)/s+2×s2){'⟩'∾˜1↓∾'⋄'∾¨(⊑"ptr"‿"ustr"‿"str"⊐<)◶⟨"""&u8"""⋄"""&u8"""⋄"""&u8:c8"""⋄"""&"⊸∾"""*"⊸∾⁼⟩¨⌾((1=𝕨)⊸/)"""*i8"""¨⌾((2=𝕨)⊸/)𝕩}¨⊢

      <˘""‿" ⇐ "‿""""‿" _R⟨"‿"#"‿" # "⟨
        ∾⟜"Raw"¨⌾((»s2LinesExtended)⊸/)·∾⟜"Ref"¨⌾((»s1LinesExtended)⊸/)LowerNames¨ ⋄ MapFuncReturnType ⋄ ∾⟜'"'¨ ⋄ MakeConstDistinct MapArgTypes¨ ⋄ (∾' '⊸∾¨)¨ ⋄ ⊢
      ⟩_MetaParse⍟(⟨⟩⊸≢){
        0‿2‿0‿3‿4‿1⊏(3↑𝕩)∾⍉{<˘⍉∘‿2⥊⊢˝˘>⊑𝕩}˘⊢˝𝕩
      }⌾⍉⍟(⟨⟩⊸≢)(1+s2Lines∨sLines)/>∾⟜⟨⟨⟩⟩⍟(3=≠)¨functions
    }
  ⟩
}


# Type of parsed define
⟨
  unknown
  macro
  guard
  int
  int_math
  long
  long_math
  float
  float_math
  double
  double_math
  char
  string
  color
⟩ ← ↕14

# Get data type and name from a string containing both
# NOTE: Useful to parse function parameters and struct fields
GetDataTypeAndName ← (∨`⌾⌽∊⟜"* ">∨`∘=⟜',')⊸(/⋈¬⊸/) #‿type‿name: # const char *typeName, int typeNameLen, char *type, char *name)

# Get comment from a line, do nothing if no comment in line
GetDescription ← ∨`∘≠⟜' '⊸/2↓∨`∘∧⟜«∘=⟜'/'⊸/ # str → description (str)

defMacro ← "#define"

# Reads list of characters 𝕩 (headerChars) that represent a header file.
# Optional 𝕨 (definePrefix), needed if you want to parse functions. It's the function prefix of choice.
# Outputs header data.
# Example1: "RLAPI" ParseHeader •FChars "file-name.h"
# Example2: ParseHeader •FChars "other-file.h"
ParseHeader ← {𝕨𝕊headerChars:
  # Example:
  # 𝕨 ← "RLAPI" # Functions define (i.e. RLAPI for raylib.h)
  definePrefix ← 𝕨⊣"NO_FUNCTIONS"

  headerLines ← nl((⊢-˜+`×¬)∘=⊔⊢)headerChars

  lines ← ' '⍟((9+@)⊸≡)¨¨ headerLines

  defines ← (∊⊑¨)⊸/ ¯1⊑¨{lastDefines𝕊linePtr:
    type ← 0
    ishex ← 0
    operand ← ⟨⟩

    LS ← ∨`∘≠⟜' ' # leading spacing
    nameAndArgs ← LS⊸/ defMacro∾⁼LS⊸/⊑linePtr # Skip defMacro, then spaces again

    # Extract name    
    nameLen ← ≤´∘⊐⟜" ("◶⟨
      1+⊐⟜')'
      ⊐⟜' '
    ⟩ nameAndArgs

    name‿args ← nameLen(↑⋈LS⊸/∘↓)nameAndArgs

    # Determine type
    {𝕊:type↩macro}⍟⊢')'=¯1⊑name
    {𝕊:type↩guard}⍟⊢(0=≠args)∨"/"≡1↑args

    {
      """"≡1↑args?
        type↩string
    ;
      "'"≡1↑args?
        type↩char
    ;
      "CLITERAL(Color)"≡15↑args?
        type↩color
    ;
      ⊑"0123456789"∊˜1↑args?
        chars ← ∧`∘≠⟜' '⊸/args
        isFloat ← ∨´'.'=chars
        isHexTemp ← ∨´'x'=chars

        {𝕤
          isFloat?
            type ↩ (𝕩='f')⊑double‿float
        ;
            type ↩ (𝕩='L')⊑int‿long
            isHex ↩ isHexTemp
        }¨(¬∘«∊⟜"0123456789xL.+-ABCDEFabcdef")⊸/chars
    ;@
    }

    # Extracting value
    fullValue ← ∨`⌾⌽∘≠⟜' '⊸/args/˜¬∨`(≠args)↑"//"⍷args
    value ← fullValue↓˜-⊑type∊long‿float # Remove number postfix

    # Extracting description
    description ← GetDescription args

    # Parse defines of type UNKNOWN to find calculated numbers
    isMath ← 1
    {𝕤
      conds ← (∊⟜"0123456789.">∊⟜"()+-*/ ")value
      numbers ← conds (¬-˜⊢×·+`»⊸>)⊸⊔ value 
      operands ← (¬conds) (¬-˜⊢×·+`»⊸>)⊸⊔ value 
      areNumbers ← ∨´¨∊⟜"0123456789xL.+-abcdefABCDEF"¨numbers
      isMath↩∧´areNumbers
      
      # Read number operand
      # Found a valid number -> update largestType
      type ⌈↩ ⌈´{
        isFloat←∨´('.'=𝕩)∧∧`∊⟜"0123456789abcdefABCDEFxL.+-"𝕩
        [
          long_math‿int_math
          float_math‿double_math
        ]⊑˜isFloat(⊣⋈⊑)"Lf"=⊑𝕩
      }¨areNumbers/numbers
      {
        # Search previous defines for operand
        # Found operand and it's a number -> update type
        foundOperands←(∧`≥⟜int∧≤⟜double_math)⊸/((𝕩≡⊑)¨/1⊸⊑¨)2↑¨lastDefines

        type⌈↩⌈´foundOperands
        isMath∧↩0<≠foundOperands
      }¨operands
      {𝕤
        # Define is a calculated number -> update type
        mathTypes ← int_math‿long_math‿float_math‿double_math‿type
        type↩mathTypes⊑˜⊑int‿long‿float‿double⊐type
      }⍟⊢isMath
    }⍟⊢type=unknown
    lastNames←⊑¨lastDefines
    𝕨 ∾⟜< name‿type‿value‿description‿ishex‿operand
  }`´(<⟨⟩)⋈↓⟜lines¨/defMacro⊸(⊣≡≠⊸↑)¨∨`∘≠⟜' '⊸/¨lines

  # Structs info data
  structs ← {𝕤
    linesPtr ← ∨`∘≠⟜' '⊸/¨𝕩↓lines

    # Parse struct description
    desc ← GetDescription (𝕩-1)⊑lines

    # Get struct name: typedef struct name {
    name←' '⊸≠⊸/∧`∘≠⟜'{'⊸/"typedef struct "∾⁼⊑linesPtr

    # Get struct fields and count them -> fields finish with ;
    fields ← ∾´{
      fieldType‿fieldNamesUnparsed ← GetDataTypeAndName ⊐⟜';'⊸↑𝕩
      fieldType ∨`∘≠⟜' '⊸/⌾⌽↩
      fieldNames ← ','((⊢-˜+`×¬)∘=⊔⊢)fieldNamesUnparsed
      fieldNames ∨`∘≠⟜' '⊸/¨↩
      fieldDesc  ←  GetDescription 𝕩

      # Move type len info from name to type
      fieldTypes ← {fieldType∾∨`∘=⟜'['⊸/𝕩}¨fieldnames
      fieldnames ∧`∘≠⟜'['⊸/¨↩

      (<fieldDesc)⊸∾¨fieldTypes⋈¨fieldNames
    }¨(∧´"struct"‿"/"‿" "≢¨6‿1‿1↑¨<)¨⊸/∨`∘≠⟜' '⊸/¨(∧`'}'≠·∾´1⊸↑¨)⊸/1↓linesPtr

    name‿desc‿fields

    # Read struct lines
    # Find structs
    # starting with "typedef struct ... {" or "typedef struct ... ; \n struct ... {"
    # ending with "} ... ;"
    # i.e. excluding "typedef struct rAudioBuffer rAudioBuffer;" -> Typedef and forward declaration only
  }¨/{
    [m1,m2]←"typedef struct"‿"struct"(⊣≡≠⊸↑)⌜ ∨`∘≠⟜' '⊸/¨𝕩
    m1∧m2«⊸∨<´∘⊐⟜"{;"¨𝕩
  } lines

  # Alias info data
  aliases ← {𝕤
    linePtr ←𝕩⊑lines
    desc ← (lines⊑˜𝕩-1)⊣⍟(""⊸≡)○GetDescription linePtr
    type‿name ← ' '((¬-˜⊢×·+`»⊸>)∘≠⊔⊢)"typedef "∾⁼⊐⟜'/'⊸↑linePtr  
    name ∾⟜";"⁼↩
    type‿name‿desc
  }¨/(∨´∘=⟜';'∧"typedef"⊸(⊣≡≠⊸↑)∧2=(+´' '⊸=>∨`∘=⟜';'))¨lines # Find aliases (lines with "typedef ... ...;")

  enums ← {
    # Parse enum description
    # NOTE: This is not necessarily from the line immediately before,
    # some of the enums have extra lines between the "description"
    # and the typedef enum
    desc ← GetDescription ⟨⟩⊸≡◶⊑‿""(∧`("// "≡3⊸↑)¨)⊸/⌾⌽𝕩↑lines

    # Parse enum value line, possible options:
    #ENUM_VALUE_NAME,
    #ENUM_VALUE_NAME
    #ENUM_VALUE_NAME     = 99
    #ENUM_VALUE_NAME     = 99,
    #ENUM_VALUE_NAME     = 0x00000040,   # Value description
    values ← {𝕤
      valueInteger ← ⟨⟩

      # We start reading the value name
      valueName←(∧`·∧˝", ="≠⌜⊢)⊸/𝕩

      # After the name we can have:
      #  '='  -> value is provided
      #  ','  -> value is equal to previous + 1, there could be a description if not '\0'
      #  ' '  -> value is equal to previous + 1, there could be a description if not '\0'
      #  '\0' -> value is equal to previous + 1

      # Let's start checking if the line is not finished
      # Two options:
      #  '='  -> value is provided
      #  ' '  -> value is equal to previous + 1, there could be a description if not '\0'
      
      valuesUnparsed←¬∘∊⟜", "⊸/valueName∾⁼⊐⟜'/'⊸↑𝕩

      value ← {"="≡1↑𝕩?
        {"0x"≡2↑𝕩?
          16⊸×⊸+˜´⌽(∾"0A"+⟜↕¨10‿6)⊐2↓𝕩
        ;
          •ParseFloat𝕩
        }'='⊸∾⁼𝕩
        ;@
      } valuesUnparsed

      # Parse value description
      valueDesc ← GetDescription 𝕩

      valueName‿value‿valueDesc
    }¨((≥⟜'A'∧'Z'⊸≥)∘⊑¨1↑¨⊢)⊸/ ∨`∘≠⟜' '⊸/¨(∧`'}'≠·⊑¨1↑¨⊢)⊸/lines↓˜1+𝕩
    
    values {𝕩=@?𝕨+1;𝕩}`⌾(1⊸⊑¨)↩
    values •Repr¨⌾(1⊸⊑¨)↩

    # Get enum name from typedef
    name←"} "∾⁼⊐⟜';'⊸↑ (⊑∘⊐⟜'}'·∾´1↑¨⊢)⊸⊑lines↓˜1+𝕩

    name‿desc‿values

    # Read enum lines
    # ignore inline enums
  }¨/("typedef enum {"⊸(⊣≡≠⊸↑)∧∨´∘≠⟜';')¨lines

  callbacks ← {
    RLS ← ∨`∘≠⟜' '⊸/
    
    # Return type
    afterDef ← RLS "typedef "∾⁼𝕩
    retType ← RLS⌾⌽ ⊐⟜'('⊸↑afterDef
    afterStar ← RLS "(*"∾⁼ RLS retType∾⁼RLS afterDef
    name ← RLS⌾⌽ ⊐⟜')'⊸↑ afterStar
    afterName ← RLS")("∾⁼RLS name∾⁼afterStar

    # ⟨paramType‿paramName, ...⟩
    [paramTypes,paramNames] ← ⍉>GetDataTypeAndName¨ ','((⊢-˜+`×¬)∘=⊔⊢) ⊐⟜')'⊸↑afterName

    # Move array sizes from name to type
    paramTypes∾¨↩⊐⟜'['⊸↓¨paramNames
    paramNames ⊐⟜'['⊸↑¨↩
    paramTypes (∨`∧∨`⌾⌽)∘≠⟜' '⊸/¨↩

    # Description
    desc ← GetDescription 𝕩

    paramCount←≠paramNames
    name‿desc‿retType‿paramTypes‿paramNames
  }¨{
    # Read callback lines
    # Find callbacks (lines with "typedef ... (* ... )( ... );")
    m1←"typedef"⊸(⊣≡≠⊸↑)¨𝕩
    m1∧{((∨´");"⊸≡˘)∧(∨´")("⊸≡˘)∧(∨´"(*"⊸≡˘))2↕" "⍟(""⊸≡)𝕩}¨𝕩
  }⊸/lines

  functions ← {
    funcSignature ← 𝕩∾⁼˜definePrefix∾' '

    retType‿name ← GetDataTypeAndName ⊐⟜'('⊸↑funcSignature
    retType (∨`∧∨`⌾⌽)∘≠⟜' '⊸/↩

    [paramTypes⋄paramNames]←⟨⟩⊸≢◶⟨↕2‿0⋄⍉>⟩("void"≢¯4⊸↑)◶⟨
      ⟨⟩ ⋄ {GetDataTypeAndName¨(∨`∧∨⟜«)∘≠⟜' '⊸/¨','((⊢-˜+`×¬)∘=⊔⊢)𝕩}
    ⟩ ⊐⟜')'⊸↑(1+⊐⟜'(')⊸↓funcSignature

    # Move array sizes from name to type
    paramTypes∾¨↩⊐⟜'['⊸↓¨paramNames
    paramTypes (∨`∧∨`⌾⌽)∘≠⟜' '⊸/¨↩

    paramNames ⊐⟜'['⊸↑¨↩

    paramTypes‿paramNames {<˘"..."⊸≡◶⟨⋈⋄"..."‿"args"⟩´˘⌾⍉>𝕩}↩

    desc ← GetDescription 𝕩

    name‿desc‿retType‿paramNames‿paramTypes

    # Read function lines
    # Read function line (starting with `define`)
  }¨definePrefix⊸(⊣≡≠⊸↑)¨⊸/lines

  defines‿structs‿aliases‿enums‿callbacks‿functions
}

# Reads header data from ParseHeader and makes a pretty json file
ToPrettyJson ← {𝕊defines‿structs‿aliases‿enums‿callbacks‿functions:
  EscapeBackslashes←∾'\'⊸=◶⋈‿"\\"¨

  # Export parsed data in json
  1↓∾nl∾¨∾⟨
    ⋈"{"

    # Print defines info
    ⋈"  ""defines"": ["
    ¯1⊸↓⌾(¯1⊸⊑)⍟(⟨⟩⊸≢)∾{𝕊name‿type‿value‿description‿ishex‿operand:∾⟨
      ⋈"    {"
      ⋈"      ""name"": """∾name∾""","
      ⋈"      ""type"": """∾(type⊑⟨
        "UNKNOWN"
        "MACRO"
        "GUARD"
        "INT"
        "INT_MATH"
        "LONG"
        "LONG_MATH"
        "FLOAT"
        "FLOAT_MATH"
        "DOUBLE"
        "DOUBLE_MATH"
        "CHAR"
        "STRING"
        "COLOR"
      ⟩)∾""","
      ⋈{isHex? # INT or LONG
        "      ""value"": "∾(16⊸×⊸+˜´⌽value⊐˜∾"0A"+⟜↕¨10‿6)∾","
      ;∨´type = int‿long‿float‿double‿string?
        "      ""value"": "∾value∾','
      ;
        "      ""value"": """∾value∾""","
      }
      ⋈"      ""description"": """∾description∾""""
      ⋈"    },"
    ⟩}¨defines
    ⋈"  ],"
    # Print structs info
    ⋈"  ""structs"": ["
    ¯1⊸↓⌾(¯1⊸⊑)⍟(⟨⟩⊸≢)∾{𝕊name‿desc‿fields:∾⟨
      ⋈"    {"
      ⋈"      ""name"": """∾name∾""","
      ⋈"      ""description"": """∾(EscapeBackslashes desc)∾""","
      ⋈"      ""fields"": ["
      ¯1⊸↓⌾(¯1⊸⊑)⍟(⟨⟩⊸≢)⟨⟩∾´{𝕊fieldDesc‿fieldType‿fieldName:⟨
        "        {"
        "          ""type"": """∾fieldType∾""","
        "          ""name"": """∾fieldName∾""","
        "          ""description"": """∾(EscapeBackslashes fieldDesc)∾""""
        "        },"
      ⟩}¨fields
      ⋈"      ]"
      ⋈"    },"
    ⟩}¨structs
    ⋈"  ],"

    # Print aliases info
    ⋈"  ""aliases"": ["
    ¯1⊸↓⌾(¯1⊸⊑)⍟(⟨⟩⊸≢)∾{𝕊type‿name‿desc:⟨
      "    {"
      "      ""type"": """∾type∾""","
      "      ""name"": """∾name∾""","
      "      ""description"": """∾desc∾'"'
      "    },"
    ⟩}¨aliases
    ⋈"  ],"

    # Print enums info
    ⋈"  ""enums"": ["
    ¯1⊸↓⌾(¯1⊸⊑)⍟(⟨⟩⊸≢)∾{𝕊name‿desc‿values:
      ∾⟨
        ⋈"    {"
        ⋈"      ""name"": """∾name∾""","
        ⋈"      ""description"": """∾(EscapeBackslashes desc)∾""","
        ⋈"      ""values"": ["
        ¯1⊸↓⌾(¯1⊸⊑)⍟(⟨⟩⊸≢)∾{𝕊valueName‿value‿valueDesc:
          ⟨
            "        {"
            "          ""name"": """∾valueName∾""","
            "          ""value"": "∾value∾","
            "          ""description"": """∾(EscapeBackslashes valueDesc)∾'"'
            "        },"
          ⟩
        }¨values
        ⋈"      ]"
        ⋈"    },"
      ⟩
    }¨enums
    ⋈"  ],"

    # Print callbacks info
    ⋈"  ""callbacks"": ["
    ¯1⊸↓⌾(¯1⊸⊑)⍟(⟨⟩⊸≢)∾{𝕊name‿desc‿retType‿paramTypes‿paramNames:∾⟨
      ⋈"    {"
      ⋈"      ""name"": """∾name∾""","
      ⋈"      ""description"": """∾(EscapeBackslashes desc)∾""",",
      ⋈"      ""returnType"": """∾retType∾""""∾","/˜⟨⟩≢paramTypes
      ⟨⟩⍟(⟨⟩≡paramTypes)∾⟨
        ⋈"      ""params"": ["
        ¯1⊸↓⌾(¯1⊸⊑)⍟(⟨⟩⊸≢)∾paramTypes{
          ⟨
            "        {"
            "          ""type"": """∾𝕨∾"""," 
            "          ""name"": """∾𝕩∾""""  
            "        },"
          ⟩
        }¨paramNames
        ⋈"      ]"
      ⟩
      ⋈"    },"
    ⟩}¨callbacks
    ⋈"  ],"

    # Print functions info
    ⋈"  ""functions"": ["
    ¯1⊸↓⌾(¯1⊸⊑)⍟(⟨⟩⊸≢)∾{𝕊name‿desc‿retType‿paramNames‿paramTypes: 
      ∾⟨
        ⋈"    {"
        ⋈"      ""name"": """∾name∾""","
        ⋈"      ""description"": """∾(EscapeBackslashes desc)∾""","
        ⋈"      ""returnType"": """∾retType∾""""∾","/˜⟨⟩≢paramTypes
        ⟨⟩⍟(⟨⟩≡paramTypes) ∾⟨
          ⋈"      ""params"": ["
          ¯1⊸↓⌾(¯1⊸⊑)⍟(⟨⟩⊸≢)∾paramTypes{
            ⟨
              "        {"
              "          ""type"": """∾𝕨∾""","
              "          ""name"": """∾𝕩∾'"'
              "        },"
            ⟩
          }¨paramNames
          ⋈"      ]"
        ⟩
        ⋈"    },"
      ⟩
    }¨functions

    ⋈"  ]"
    ⋈"}"
  ⟩
}

HeaderToFFI ← ToFFI ParseHeader