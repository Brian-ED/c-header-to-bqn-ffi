⟨
  HeaderToFFI  # Read string 𝕩 and optional function prefix 𝕨, outputs metaprogrammed file as string
  ToFFI        # turns header data from ParseHeader into ffi file characters
  ParseHeader  # Read string 𝕩 and optional function prefix 𝕨, outputs header data
  ToPrettyJson # Read header data from ParseHeader and makes a pretty json file
  SetPath      # Set the path of the resulting FFI script from ToFFI
⟩⇐

⟨ParseJSON⇐Parse⟩ ← •Import "json.bqn"

# util functions
nl ← @+10 # newline
wnl ← @+13 # windows newline prefix
Box ← ⟨⟩⊸≡◶⟨>⋄↕0‿0⟩⊢»¨⟜<' '⥊˜0⌈´≠¨
LowerNames ← +⟜(32×1="A["⊸⍋)⌾(1↑⎉1⊢)⍟(⟨⟩⊸≢)
_MetaParse ← {∾˘´[𝕗,𝕨]{F‿w𝕊𝕩:<w⊸∾˘Box F𝕩}˘○⍉↕∘0‿3⍟(⟨⟩⊸≡)𝕩}

remap ← {𝕏⌾⌽}{𝕎𝕏}´{(𝕨⊸≡∧"*"≡1↑⊣)◶⟨⋈⋄𝕩⋈˜1↓⊣⟩´}´¨⟨
  "unsigned char"  ‿"ustr"
  "char"           ‿"str"
  "void"           ‿"ptr"
  "rAudioBuffer"   ‿"ptr"
  "rAudioProcessor"‿"ptr"
⟩
constText←"const "

SwitchOrder ← {⌽⌾((𝕩∊'0'+↕10)⊸/)1⊸⌽⌾((𝕩∊"[]")⊸/)𝕩}⌽

shortendStructNames←[
  "v2"‿"Vector2"
  "v3"‿"Vector3"
  "v4"‿"Vector4"
]

typeMapping ← ⟨
  "UNKNOWN"
  "MACRO"
  "GUARD"
  "INT"
  "INT_MATH"
  "LONG"
  "LONG_MATH"
  "FLOAT"
  "FLOAT_MATH"
  "DOUBLE"
  "DOUBLE_MATH"
  "CHAR"
  "STRING"
  "COLOR"
⟩

typeReplacements ← ⍉shortendStructNames∾[
  # remove since they're not defined
  "ptr"‿"AudioCallback"
  "ptr"‿"LoadFileDataCallback"
  "ptr"‿"LoadFileTextCallback"
  "ptr"‿"SaveFileDataCallback"
  "ptr"‿"SaveFileTextCallback"
  "ptr"‿"TraceLogCallback"

  """f64"""‿"double"
  """i64"""‿"long"
  "f"      ‿"float"
  "i"      ‿"int"
  "ptr"    ‿"..."
  "u"      ‿"unsigned int"
  "u8"     ‿"char"
  "u8"     ‿"unsigned char"
  """u16"""‿"unsigned short"
  " "      ‿"void"
]

SetPath ← {path𝕊ffi:
  default ← "⊑•args" # defaultPathDefinition
  (⊐⟜1 default⍷ffi)(↑∾'"'∾path∾'"'∾default∾⁼↓)ffi
}

# turns header data from ParseHeader into ffi file characters
# 𝕨 is an optional name mapping, used so you can rename functions and fix name collisions
#   If the resulting name collides with a already-defined name, it errors.
## Example1: ToFFI ParseHeader file.h
## Example2: [⟨"bad_name"⟩⋄⟨"CoolName"⟩] ToFFI ParseHeader file.h
ToFFI ← {𝕨𝕊data: nameMapping ← 𝕨⊣↕2‿0
  # TODO check validity of names in the mapping

  MapNames ← {
    [old⋄new]←nameMapping
    (new⊏˜old⊸⊐)⌾((𝕩∊old)⊸/)𝕩
  }

  mapArgTypes ← {
    [bqn,c] ← typeReplacements
    {
      cleaned←constText⊸∾⁼¨⌾((constText⊸(⊣≡≠⊸↑)¨𝕩)⊸/)𝕩
      [kept,removed] ← 2‿∘⥊⍉Remap˘(↕0‿2)∾´∨`∘∊⟜"[*"⊸{⟨∨`⌾⌽∘≠⟜' '⊸/𝕩/˜¬𝕨 ⋄ SwitchOrder 𝕨/𝕩⟩}¨cleaned
      replaced ← kept LowerNames∘(MapNames⌾⋈)∘⊣⍟(0⊸≡)¨(c⊐kept)⊏bqn∾0
      removed {""𝕊𝕩:𝕩;'"'≡⊑𝕩?𝕨⊸∾⌾('"'⊸∾⁼)𝕩;'"'∾𝕨∾"""∾"∾𝕩}¨ replaced
    }
  }

  AddRemoved ← {
    ""𝕊𝕩:𝕩;
    '"'≡⊑𝕩?𝕨⊸∾⌾('"'⊸∾⁼)𝕩;
    '"'∾𝕨∾"""∾"∾𝕩
  }

  MapStructTypes ← {
    [bqn,c] ← typeReplacements
    cleaned←constText⊸∾⁼¨⌾((constText⊸(⊣≡≠⊸↑)¨𝕩)⊸/)𝕩
    [kept,removed] ← 2‿∘⥊⍉Remap˘(↕0‿2)∾´∨`∘∊⟜"[*"⊸{⟨∨`⌾⌽∘≠⟜' '⊸/𝕩/˜¬𝕨 ⋄ SwitchOrder 𝕨/𝕩⟩}¨cleaned
    replaced ← kept LowerNames∘(MapNames⌾⋈)∘⊣⍟(0⊸≡)¨(c⊐kept)⊏bqn∾0
    removed AddRemoved¨ replaced
  }

  MapStructNames ← {
    [bqn,c]←⍉shortendStructNames
    𝕩LowerNames∘(MapNames⌾⋈)∘⊣⍟(0⊸≡)¨(c⊐𝕩)⊏bqn∾0
  }

  MapFuncReturnType ← {
    [bqn,c] ← typeReplacements
    cleaned←𝕩↓˜¨constText≠⊸×constText⊸(⊣≡≠⊸↑)¨𝕩
    [kept,removed] ← 2‿∘⥊⍉Remap˘(↕0‿2)∾´ ∨`∘∊⟜"[*"⊸(¬⊸/∾⟜" "⁼⍟(" "≡¯1⊸↑)⊸⋈SwitchOrder∘/)¨cleaned
    replaced ← kept LowerNames∘(MapNames⌾⋈)∘⊣⍟(0⊸≡)¨(c⊐kept)⊏bqn∾0
    {'('∾𝕩∾')'}⍟(∨´"∾⊣"⊸∊)¨"ptr⊣"⊸∾⍟(("ustr"≡¯4⊸↑)∨"str"≡¯3⊸↑)¨ removed AddRemoved¨ replaced
  }

  defines‿structs‿aliases‿enums‿callbacks‿functions←{
    !𝕩⊣˝⊸≡"defines"‿"structs"‿"aliases"‿"enums"‿"callbacks"‿"functions"
    ⊢˝¨¨⌾(0‿1‿3‿4‿5⊸⊏)⊢˝𝕩
  } ParseJSON ToPrettyJson data

  top ← 1↓∾nl∾¨⟨
    "#### THIS TEXT HAS BEEN AUTOGENERATED ####"
    ""
    •FChars "setupMacro.bqn"
  ⟩

  definesDone ← {
    exclTypes  ← "GUARD"‿"MACRO"‿"UNKNOWN"‿"FLOAT_MATH"‿"COLOR"
    filtered ← {𝕊name‿type‿val‿desc:
      ¬(⟨⟩≡val)∨´type⊸≡¨exclTypes
    }˘⊸/(↕0‿4)∾´defines
    "Multiple defines(#define) have the same name"!∧´∊⊏⍉filtered
    <˘""‿""‿" ⇐ "‿" # "⟨LowerNames¨MapNames,⟨⟩¨,•Repr¨,⊢⟩_MetaParse filtered
  }

  enumsDone ← {
    [names,descriptions,values]←⍉(↕0‿3)∾´enums
    tabled ←((↕0‿3)∾´⊢˝¨)¨ values
    bodys ← (<˘"  "‿" ⇐ "‿"  # "⟨LowerNames¨MapNames,•Repr¨,⊢⟩_MetaParse⊢)¨tabled
    headers ← (MapNames names) LowerNames⊸∾¨<˘" ⇐ { # "⊸∾˘Box descriptions
    ⟨⟩∾´headers<⊸∾¨∾⟜⟨"}"⟩¨bodys
  }

  structsDone ← {
    [names,descriptions,fields]←⍉(↕0‿3)∾´structs
    headers ← (MapStructNames names) ∾⟜" ⇐ ⟨ # "⊸∾¨ descriptions
    bodys ← {⟨"⟩"⟩∾˜<˘"  "‿" # "‿"  # "⟨MapStructTypes,⊢,⊢⟩_MetaParse (↕0‿3)∾´𝕩}¨⊢˝¨¨fields
    assembled ← headers <⊸∾¨ bodys
    aliasLines←»⊸∨∘≠⟜' '⊸/¨<˘""‿" ⇐ "‿" # "⟨LowerNames¨MapNames,MapArgTypes,⊢⟩_MetaParse 1‿0‿2⊸⊏˘(↕0‿3)∾´⊢˝¨aliases
    p←⊑¨⊢˝¨aliases
    "Multiple structs and/or struct aliases have the same name"!∧´∊names∾1⊸⊏˘(↕0‿3)∾´⊢˝¨aliases
    ∾ ∾∾⟜(<⋈)¨⟜aliasLines⌾(¯1⊸↓)assembled⊔˜+`»+˝p≡⌜names
  }

  functionsDone ← {
    s ← {
      ((⊑'*'⊸∊)¨∧constText⊸(⊣≢≠⊸↑)¨)1‿0⊸⊑¨¯1⊑𝕩
    }¨∾⟜⟨⟨⟩⟩⍟(3=≠)¨functions
    sLines←∨´¨s

    s2 ← {
      "const void *"⊸≡¨1‿0⊸⊑¨¯1⊑𝕩
    }¨∾⟜⟨⟨⟩⟩⍟(3=≠)¨functions
    s2Lines←∨´¨s2
    !∧´¬s2Lines∧sLines # I don't want the lines to collide

    sAllLinesExtended ← (↕∘≠⊸+⌾/↑˜+´+≠)s2Lines∨sLines
    s1LinesExtended‿s2LinesExtended ← s2Lines{((+´+≠)𝕩+𝕨)↑𝕨⊸{(¬𝕩∊/𝕨)/𝕩+↕≠𝕩}⌾/𝕨+𝕩}{𝔽⋈𝔽˜}sLines
    MakeConstDistinct ← (sAllLinesExtended¬⊸×(1+s2Lines∨sLines)/s+2×s2){'⟩'∾˜1↓∾'⋄'∾¨(⊑"ptr"‿"ustr"‿"str"⊐<)◶⟨"""&u8"""⋄"""&u8"""⋄"""&u8:c8"""⋄"""&"⊸∾"""*"⊸∾⁼⟩¨⌾((1=𝕨)⊸/)"""*i8"""¨⌾((2=𝕨)⊸/)𝕩}¨⊢

    <˘""‿" ⇐ "‿""""‿" _R⟨"‿"#"‿" # "⟨
      ∾⟜"Raw"¨⌾((»s2LinesExtended)⊸/)·∾⟜"Ref"¨⌾((»s1LinesExtended)⊸/)LowerNames¨∘MapNames ⋄ MapFuncReturnType ⋄ ∾⟜'"'¨ ⋄ MakeConstDistinct MapArgTypes¨ ⋄ (∾' '⊸∾¨)¨ ⋄ ⊢
    ⟩_MetaParse⍟(⟨⟩⊸≢){
      0‿2‿0‿3‿4‿1⊏(3↑𝕩)∾⍉{<˘⍉(↕0‿2)∾´⊢˝¨<⁼𝕩}˘⊢˝𝕩
    }⌾⍉⍟(⟨⟩⊸≢)(1+s2Lines∨sLines)/(↕0‿4)∾´∾⟜⟨⟨⟩⟩⍟(3=≠)¨functions
  }

  nl∾˜top∾∾nl∾¨∨`⌾⌽∘≠⟜' '⊸/¨∾1↓∾⟨""⟩⊸⋈¨definesDone‿enumsDone‿structsDone‿functionsDone
}

# Type of parsed define
⟨
  unknown
  macro
  guard
  int
  int_math
  long
  long_math
  float
  float_math
  double
  double_math
  char
  string
  color
⟩ ← ↕14

# Get data type and name from a string containing both
# NOTE: Useful to parse function parameters and struct fields
GetDataTypeAndName ← (∨`⌾⌽∊⟜"* ">∨`∘=⟜',')⊸(/⋈¬⊸/) # type‿name: # const char *typeName, int typeNameLen, char *type, char *name)

# Get comment from a line, do nothing if no comment in line
GetDescription ← ∨`∘≠⟜' '⊸/2↓∨`∘∧⟜«∘=⟜'/'⊸/ # str → description (str)

defMacro ← "#define"

# Reads list of characters 𝕩 (headerChars) that represent a header file.
# Optional 𝕨 (definePrefix), needed if you want to parse functions. It's the function prefix of choice.
# Outputs header data.
# Example1: "RLAPI" ParseHeader •FChars "file-name.h"
# Example2: ParseHeader •FChars "other-file.h"
ParseHeader ← {𝕨𝕊headerChars:
  SingleLineComments ← {0{𝕨𝕊0‿0:𝕨;1⊑𝕩}`(nl=𝕩) ⋈¨ ∧⟜«'/'=𝕩}
  MultiLineComments ← {((/0≠0∾d)!0=+´d)⊢0≠+`d←-˝"/*"‿"*/"≡⌜𝕩}
  LinesToChars ← {𝕊⁼: (+`×¬)⊸-∘=⟜nl⊸⊔𝕩; 1↓""∾´nl∾¨𝕩}
  # Example:
  # 𝕨 ← "RLAPI" # Functions define (i.e. RLAPI for raylib.h)
  definePrefix ← 𝕨⊣"NO_FUNCTIONS"

  headerLines ← nl((+`×¬)⊸-∘=⊔⊢) wnl⊸≠⊸/ headerChars

  lines ← ' '⍟((9+@)⊸≡)¨¨ headerLines

  defines ← (∊⊑¨)⊸/ ¯1⊑¨{lastDefines𝕊𝕩: defineLine←⊑𝕩
    name‿args ← defineLine {𝕎𝕩}´⌽⟨
      (∨`∧∨`⌾⌽)∘(∧`∘∨⟜«⊸∧˝"/ "≠⌜⊢)⊸/
      defMacro⊸∾⁼ # Skip defMacro
      ∨`∘≠⟜' '⊸/ # skip spaces
      ≤´∘⊐⟜" ("◶⟨1+⊐⟜')' ⋄ ⊐⟜' '⟩⊸(↑⋈∨`∘≠⟜' '⊸/∘↓) # name‿args
    ⟩
    # Determine type
    ishex ← 0
    type ← {
      """"≡1↑args?
        string
    ;
      "'"≡1↑args?
        char
    ;
      "CLITERAL(Color)"(⊣≡≠⊸↑)args?
        color
    ;
      ⊑"0123456789"∊˜1↑args?
        chars ← ∧`∘≠⟜' '⊸/args # up to first space
        isHex ↩ ∨´'x'=chars
        {𝕤
          ∨´'.'=chars?
            double‿float⊑˜'f'=𝕩
        ;
          int‿long⊑˜'L'=𝕩
        }⊑¬∘«∘∊⟜"0123456789xL.+-ABCDEFabcdef"⊸/chars
    ;
      type ← unknown‿macro⊑˜")"≡¯1↑name
      type‿guard⊑˜0=≠args
    }
    # Extracting value
    value ← args↓˜-⊑type∊long‿float # Remove number postfix

    # Extracting description
    description ← GetDescription defineLine

    # Parse defines of type UNKNOWN to find calculated numbers
    {𝕤
      numberLetters ← "0123456789xL.+-abcdefABCDEF"
      numbers ← (¬-˜⊢×·+`»⊸>)∘∊⟜"0123456789."⊸⊔ value
      operands ← (¬-˜⊢×·+`»⊸>)∘∊⟜"()+-*/ "⊸⊔ value

      numTypes ← ⟨
        int
        int_math
        long
        long_math
        float
        float_math
        double
        double_math
      ⟩
      # Search previous defines for operand
      # Found operand and it's a number -> update type
      [names,types] ← ⍉(↕0‿2)∾´2↑¨lastDefines

      areNums ← numTypes∊˜typeMapping⊐types
      type ⌈´↩ {⌈´types/˜areNums∧𝕩}˘operands≡⌜names

      areNumbers ← ∧´∘∊⟜"0123456789xL.+-abcdefABCDEF"¨numbers
      isMath←∧´areNumbers

      # Read number operand
      # Found a valid number -> update largestType
      type ⌈´↩ {
        isFloat←∨´('.'=𝕩)∧∧`𝕩∊"0123456789abcdefABCDEFxL.+-"
        [
          long_math‿int_math
          float_math‿double_math
        ]⊑˜isFloat(⊣⋈⊑)"Lf"=⊑𝕩
      }¨areNumbers/numbers

      # Search previous defines for operand
      # Found operand and it's a number -> update type
      foundOperands ← {
        (∧`≥⟜int∧≤⟜double_math)⊸/𝕩⊸≡¨⊸/˝⍉(↕0‿2)∾´2↑¨lastDefines
      }¨operands

      type⌈´↩⌈´¨foundOperands
      isMath∧´↩0<≠¨foundOperands

      {𝕤
        # Define is a calculated number -> update type
        mathTypes ← int_math‿long_math‿float_math‿double_math‿type
        type↩mathTypes⊑˜⊑int‿long‿float‿double⊐type
      }⍟⊢isMath
    }⍟⊢type=unknown
    lastNames←⊑¨lastDefines
    value {'-'⍟('¯'⊸≡)¨•Repr 16⊸×⊸+˜´⌽(∾"0A"+⟜↕¨10‿6)⊐-⟜(32×1="a{"⊸⍋)"0x"∾⁼𝕩}⍟ishex↩
    value {
      ∨´type=int‿long‿float‿double?
        𝕩
    ;
      type = string?
        𝕩
    ;
      '"'∾𝕩∾'"'
    }↩

    𝕨 ∾⟜< name‿(type⊑typeMapping)‿value‿description
  }`´(<⟨⟩)⋈↓⟜lines¨/defMacro⊸(⊣≡≠⊸↑)¨∨`∘≠⟜' '⊸/¨ {""¨⌾((MultiLineComments𝕩)⊸/)𝕩} ¬∘SingleLineComments⊸/⌾LinesToChars lines

  # Structs info data
  structs ← (⊑¨¬⊸/1⊸⊑¨){𝕤
    structLines ← ∨`∘≠⟜' '⊸/¨𝕩↓lines
    desc ← GetDescription (𝕩-1)⊑lines # Parse struct description
    name←' '⊸≠⊸/∧`∘≠⟜'{'⊸/"struct "∾⁼"typedef "(⊢↓˜≠∘⊣×⊣≡≠⊸↑)⊑structLines # Get struct name: typedef struct name {
    skipMe ← (⟨⟩≡name)∨¬∧´name∊∾'_'∾"aA0"+↕¨26‿26‿10
    •Out⍟skipMe "Warning: struct skipped with name """∾name∾""". Struct name invalid."
    fieldLines ← (∧˝"/ "≠⌜' '⊣´¨⊢)⊸/∨`∘≠⟜' '⊸/¨(∧`'}'≠' '⊣´¨⊢)⊸/1↓structLines
    Warning←{𝕩⊣•Out {∧´name∊∾"aA0"+↕¨26‿26‿10?𝕨∾" named "∾𝕩∾˜•Repr name;𝕨∾𝕩}´ "Warning: struct"‿" skipped. Structs or enums in struct fields are not allowed. Nested structs will likely be skipped due to empty prefix names."}
    skipMe ∨↩ Warning⍟⊢ ∨´∨˝"struct"‿"enum"(≡⌜∨∾¨⟜' '(⊣≡7↑⊢)⌜⊢)fieldLines

    fields ← ∾´{ # Get struct fields and count them -> fields finish with ;
      fieldType‿fieldNamesUnparsed ← ∨`⌾⌽∘≠⟜' '⊸/¨ GetDataTypeAndName ⊐⟜';'⊸↑𝕩
      fieldNames ← ∨`∘≠⟜' '⊸/¨ ','((⊢-˜+`×¬)∘=⊔⊢)fieldNamesUnparsed # "m0, m4, m8, m12"
      fieldDesc  ← GetDescription 𝕩

      # Move type len info from name to type
      fieldTypes ← fieldType⊸∾¨∨`∘=⟜'['⊸/¨fieldnames
      fieldnames ∧`∘≠⟜'['⊸/¨↩

      fieldTypesNonRecursive ← {"ptr"¨⌾((name⊸≡¨∧`∘¬∘∊⟜"* "⊸/¨𝕩)⊸/)𝕩}fieldTypes
      (<fieldDesc)⊸∾¨fieldTypesNonRecursive⋈¨fieldNames
    }¨fieldLines

    ⟨skipMe⋄name‿desc‿fields⟩

    # Read struct lines
    # Find structs
    # starting with "typedef struct ... {" or "typedef struct ... ; \n struct ... {"
    # ending with "} ... ;"
    # i.e. excluding "typedef struct rAudioBuffer rAudioBuffer;" -> Typedef and forward declaration only
  }¨/{
    [m1,m2]←"typedef struct"‿"struct"(⊣≡≠⊸↑)⌜ ∨`∘≠⟜' '⊸/¨𝕩
    m2∨m1∧m2 0⊸«⊸∨<´∘⊐⟜"{;"¨𝕩
  } {""¨⌾((MultiLineComments𝕩)⊸/)𝕩} ¬∘SingleLineComments⊸/⌾LinesToChars lines

  # Alias info data
  aliases ← {𝕤
    aliasLine ← 𝕩⊑lines
    desc ← (lines⊑˜𝕩-1)⊣⍟(""⊸≡)○GetDescription aliasLine
    type‿name ← ' '((¬-˜⊢×·+`»⊸>)∘≠⊔⊢)"typedef "∾⁼⊐⟜'/'⊸↑aliasLine
    name ∾⟜";"⁼↩
    type‿name‿desc
  }¨/(∨´∘=⟜';'∧"typedef"⊸(⊣≡≠⊸↑)∧2=(+´' '⊸=>∨`∘=⟜';'))¨lines # Find aliases (lines with "typedef ... ...;")

  enums ← {
    # Parse enum description
    # NOTE: This is not necessarily from the line immediately before,
    # some of the enums have extra lines between the "description"
    # and the typedef enum
    desc ← GetDescription ⟨⟩⊸≡◶⊑‿""(∧`("// "≡3⊸↑)¨)⊸/⌾⌽𝕩↑lines

    # Parse enum value line, possible options:
    #ENUM_VALUE_NAME,
    #ENUM_VALUE_NAME
    #ENUM_VALUE_NAME     = 99
    #ENUM_VALUE_NAME     = 99,
    #ENUM_VALUE_NAME     = 0x00000040,   # Value description
    values ← {𝕤
      valueInteger ← ⟨⟩

      # We start reading the value name
      valueName←(∧`·∧˝", ="≠⌜⊢)⊸/𝕩

      # After the name we can have:
      #  '='  -> value is provided
      #  ','  -> value is equal to previous + 1, there could be a description if not '\0'
      #  ' '  -> value is equal to previous + 1, there could be a description if not '\0'
      #  '\0' -> value is equal to previous + 1

      # Let's start checking if the line is not finished
      # Two options:
      #  '='  -> value is provided
      #  ' '  -> value is equal to previous + 1, there could be a description if not '\0'

      valuesUnparsed←¬∘∊⟜", "⊸/valueName∾⁼⊐⟜'/'⊸↑𝕩

      value ← {"="≡1↑𝕩?
        {"0x"≡2↑𝕩?
          16⊸×⊸+˜´⌽(∾"0A"+⟜↕¨10‿6)⊐-⟜(32×1="a{"⊸⍋)2↓𝕩
        ;
          •ParseFloat𝕩
        }'='⊸∾⁼𝕩
        ;@
      } valuesUnparsed

      # Parse value description
      valueDesc ← GetDescription 𝕩

      valueName‿value‿valueDesc
    }¨((≥⟜'A'∧'Z'⊸≥)∘⊑¨1↑¨⊢)⊸/ ∨`∘≠⟜' '⊸/¨(∧`'}'≠·⊑¨1↑¨⊢)⊸/lines↓˜1+𝕩

    values {𝕩=@?𝕨+1;𝕩}`⌾(1⊸⊑¨)↩
    values ('-'⍟('¯'⊸≡)¨•Repr)¨⌾(1⊸⊑¨)↩

    # Get enum name from typedef
    name←"} "∾⁼⊐⟜';'⊸↑ (⊑∘⊐⟜'}'·∾´1↑¨⊢)⊸⊑lines↓˜1+𝕩

    name‿desc‿values

    # Read enum lines
    # ignore inline enums
  }¨/("typedef enum {"⊸(⊣≡≠⊸↑)∧∨´∘≠⟜';')¨ {""¨⌾((MultiLineComments𝕩)⊸/)𝕩} ¬∘SingleLineComments⊸/⌾LinesToChars lines

  callbacks ← {
    RLS ← ∨`∘≠⟜' '⊸/

    # Return type
    afterDef ← RLS "typedef "∾⁼𝕩
    retType ← RLS⌾⌽ ⊐⟜'('⊸↑afterDef
    afterStar ← RLS "(*"∾⁼ RLS retType∾⁼RLS afterDef
    name ← RLS⌾⌽ ⊐⟜')'⊸↑ afterStar
    afterName ← RLS")("∾⁼RLS name∾⁼afterStar

    # ⟨paramType‿paramName, ...⟩
    [paramTypes,paramNames] ← ⍉>GetDataTypeAndName¨ ','((⊢-˜+`×¬)∘=⊔⊢) ⊐⟜')'⊸↑afterName

    # Move array sizes from name to type
    paramTypes∾¨↩⊐⟜'['⊸↓¨paramNames
    paramNames ⊐⟜'['⊸↑¨↩
    paramTypes (∨`∧∨`⌾⌽)∘≠⟜' '⊸/¨↩

    # Description
    desc ← GetDescription 𝕩

    name‿desc‿retType‿paramTypes‿paramNames
  }¨{
    # Read callback lines
    # Find callbacks (lines with "typedef ... (* ... )( ... );")
    m1←"typedef"⊸(⊣≡≠⊸↑)¨𝕩
    m1∧{((∨´");"⊸≡˘)∧(∨´")("⊸≡˘)∧(∨´"(*"⊸≡˘))2↕" "⍟(""⊸≡)𝕩}¨𝕩
  }∘{""¨⌾((MultiLineComments𝕩)⊸/)𝕩}⊸/lines

  functions ← {
    funcSignature ← 𝕩∾⁼˜definePrefix∾' '

    retType‿name ← GetDataTypeAndName ⊐⟜'('⊸↑funcSignature
    retType (∨`∧∨`⌾⌽)∘≠⟜' '⊸/↩

    [paramTypes⋄paramNames]←⟨⟩⊸≢◶⟨↕2‿0⋄⍉>⟩("void"≢¯4⊸↑)◶⟨
      ⟨⟩ ⋄ {GetDataTypeAndName¨(∨`∧∨⟜«)∘≠⟜' '⊸/¨','((⊢-˜+`×¬)∘=⊔⊢)𝕩}
    ⟩ ⊐⟜')'⊸↑(1+⊐⟜'(')⊸↓funcSignature

    # Move array sizes from name to type
    paramTypes∾¨↩⊐⟜'['⊸↓¨paramNames
    paramTypes (∨`∧∨`⌾⌽)∘≠⟜' '⊸/¨↩

    paramNames ⊐⟜'['⊸↑¨↩

    paramTypes‿paramNames {<˘"..."⊸≡◶⟨⋈⋄"..."‿"args"⟩´˘⌾⍉>𝕩}↩

    desc ← GetDescription 𝕩

    name‿desc‿retType‿paramNames‿paramTypes

    # Read function lines
    # Read function line (starting with `define`)
  }¨definePrefix⊸(⊣≡≠⊸↑)¨∘{""¨⌾((MultiLineComments𝕩)⊸/)𝕩}⊸/lines

  defines‿structs‿aliases‿enums‿callbacks‿functions
}

⟨UnEscape, Escape⟩ ← {
  in ← """\/bfrnt"
  out ← (3↑in)∾@+8‿12‿13‿10‿9
  diff ← (out-in) ∾ 0
  Basic ← {
    i ← in ⊐ 𝕩
    "Unknown escape" ! ∧´𝕨≤i<≠in
    𝕩 + 𝕨 × i ⊏ diff
  }

  hc ← "0Aa"
  hb ← ⥊hc+0≍˘10‿6‿6   # Hex boundaries, start and after-end
  ho ← 2/hc-0‿10‿10    # Corresponding offsets
  Hex ← { u 𝕊 𝕩:
    d ← 𝕩 /˜ m ← ≠` (4⥊0)⊸»⊸≠ »u
    t ← hb ⍋ d
    "String \u must be followed by 4 hex characters" ! ∧´1=2|t
    # Now m can't run past the end or self-intersect,
    # or it would have hit a closing quote or backslash
    v ← 16⊸×⊸+˜˝⌽ ⍉∘‿4⥊ d-t⊏ho
    w‿e ← Surrogate v
    ⟨(w+@-'u')⊸+⌾(u⊸/)𝕩, e⌾(u⊸/)m⟩
  }
  sr ← 2⋆10            # Surrogate base/radix
  sb ← sr×52+2+↕3      # Surrogate character boundaries
  Surrogate ← {
    c ← (≠sb)|sb⍋𝕩     # 0 for non-surrogate, 1 then 2 for surrogate
    h ← 1=c            # First half
    "Unmatched surrogate pair" ! (0∾h) ≡ (2=c)∾0
    r ← 𝕩 - c⊏0∾sb     # Numeric value of surrogates
    v ← r + »h×sr×(2⋆6)+r
    ⟨v, h⟩
  }

  UnEscape ⇐ { e 𝕊 𝕩:
    u ← e ∧ 𝕩='u'
    (u<e)⊸Basic⌾⊑ u Hex⟜⊑⍟(∨´u) 𝕩‿0
  }

  Hex32 ← {                # Convert 𝕩<32 to two hex digits
    u‿l ← 16(⌊∘÷˜⋈|)𝕩      # Upper and lower digits; ∧´u<2
    '0'+u≍˘l-(10+-´"0A")×10≤l
  }
  Escape ⇐ {
    e ← (𝕩∊2↑in) ∨ 𝕩<@+32  # Quote, backslash, and control characters
    j ← /e ⋄ k ← ¬e        # Their indices; characters to keep
    c ← j ⊏ 𝕩              # Characters to be escaped
    m ← c - (out⊐c)⊏diff   # Escape the basic ones
    g ← 2 ∾˜ m<@+32        # Group 𝕨 to separate...
    n‿u ← g ⊔ m            # Characters requiring basic, hex escapes
    i ← ∾⟨/k⟩∾2‿6/¨g⊔j     # Target indices
    i ⍋⊸⊏ ∾⟨               # Use them to reorder:
      k/𝕩                  # Kept characters
      ⥊'\'≍˘n              # Basic escapes
      ⥊"\u00"⊸∾˘ Hex32 u-@ # Hex escapes
    ⟩
  }
}

# Reads header data from ParseHeader and makes a pretty json file
ToPrettyJson ← {𝕊defines‿structs‿aliases‿enums‿callbacks‿functions:
  EscapeBackslashes←∾'\'⊸=◶⋈‿"\\"¨

  # Export parsed data in json
  1↓∾nl∾¨∾⟨
    ⋈"{"

    # Print defines info
    ⋈"  ""defines"": ["
    ¯1⊸↓⌾(¯1⊸⊑)⍟(⟨⟩⊸≢)⟨⟩∾´{𝕊name‿type‿value‿description:⟨
      "    {"
      "      ""name"": """∾name∾""","
      "      ""type"": """∾type∾""","
      "      ""value"": "∾value∾','
      "      ""description"": """∾(Escape description)∾""""
      "    },"
    ⟩}¨defines
    ⋈"  ],"
    # Print structs info
    ⋈"  ""structs"": ["
    ¯1⊸↓⌾(¯1⊸⊑)⍟(⟨⟩⊸≢)⟨⟩∾´{𝕊name‿desc‿fields:∾⟨
      ⋈"    {"
      ⋈"      ""name"": """∾name∾""","
      ⋈"      ""description"": """∾(Escape desc)∾""","
      ⋈"      ""fields"": ["
      ¯1⊸↓⌾(¯1⊸⊑)⍟(⟨⟩⊸≢)⟨⟩∾´{𝕊fieldDesc‿fieldType‿fieldName:⟨
        "        {"
        "          ""type"": """∾fieldType∾""","
        "          ""name"": """∾fieldName∾""","
        "          ""description"": """∾(Escape fieldDesc)∾""""
        "        },"
      ⟩}¨fields
      ⋈"      ]"
      ⋈"    },"
    ⟩}¨structs
    ⋈"  ],"

    # Print aliases info
    ⋈"  ""aliases"": ["
    ¯1⊸↓⌾(¯1⊸⊑)⍟(⟨⟩⊸≢)⟨⟩∾´{𝕊type‿name‿desc:⟨
      "    {"
      "      ""type"": """∾type∾""","
      "      ""name"": """∾name∾""","
      "      ""description"": """∾desc∾'"'
      "    },"
    ⟩}¨aliases
    ⋈"  ],"

    # Print enums info
    ⋈"  ""enums"": ["
    ¯1⊸↓⌾(¯1⊸⊑)⍟(⟨⟩⊸≢)⟨⟩∾´{𝕊name‿desc‿values:
      ∾⟨
        ⋈"    {"
        ⋈"      ""name"": """∾name∾""","
        ⋈"      ""description"": """∾(Escape desc)∾""","
        ⋈"      ""values"": ["
        ¯1⊸↓⌾(¯1⊸⊑)⍟(⟨⟩⊸≢)⟨⟩∾´{𝕊valueName‿value‿valueDesc:
          ⟨
            "        {"
            "          ""name"": """∾valueName∾""","
            "          ""value"": "∾value∾","
            "          ""description"": """∾(Escape valueDesc)∾'"'
            "        },"
          ⟩
        }¨values
        ⋈"      ]"
        ⋈"    },"
      ⟩
    }¨enums
    ⋈"  ],"

    # Print callbacks info
    ⋈"  ""callbacks"": ["
    ¯1⊸↓⌾(¯1⊸⊑)⍟(⟨⟩⊸≢)⟨⟩∾´{𝕊name‿desc‿retType‿paramTypes‿paramNames:∾⟨
      ⋈"    {"
      ⋈"      ""name"": """∾name∾""","
      ⋈"      ""description"": """∾(Escape desc)∾""",",
      ⋈"      ""returnType"": """∾retType∾""""∾","/˜⟨⟩≢paramTypes
      ⟨⟩⍟(⟨⟩≡paramTypes)∾⟨
        ⋈"      ""params"": ["
        ¯1⊸↓⌾(¯1⊸⊑)⍟(⟨⟩⊸≢)⟨⟩∾´paramTypes{
          ⟨
            "        {"
            "          ""type"": """∾𝕨∾""","
            "          ""name"": """∾𝕩∾""""
            "        },"
          ⟩
        }¨paramNames
        ⋈"      ]"
      ⟩
      ⋈"    },"
    ⟩}¨callbacks
    ⋈"  ],"

    # Print functions info
    ⋈"  ""functions"": ["
    ¯1⊸↓⌾(¯1⊸⊑)⍟(⟨⟩⊸≢)⟨⟩∾´{𝕊name‿desc‿retType‿paramNames‿paramTypes:
      ∾⟨
        ⋈"    {"
        ⋈"      ""name"": """∾name∾""","
        ⋈"      ""description"": """∾(Escape desc)∾""","
        ⋈"      ""returnType"": """∾retType∾""""∾","/˜⟨⟩≢paramTypes
        ⟨⟩⍟(⟨⟩≡paramTypes) ∾⟨
          ⋈"      ""params"": ["
          ¯1⊸↓⌾(¯1⊸⊑)⍟(⟨⟩⊸≢)⟨⟩∾´paramTypes{
            ⟨
              "        {"
              "          ""type"": """∾𝕨∾""","
              "          ""name"": """∾𝕩∾'"'
              "        },"
            ⟩
          }¨paramNames
          ⋈"      ]"
        ⟩
        ⋈"    },"
      ⟩
    }¨functions

    ⋈"  ]"
    ⋈"}"
  ⟩
}

HeaderToFFI ← ToFFI ParseHeader
